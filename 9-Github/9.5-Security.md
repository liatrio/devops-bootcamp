# Github Security

## Code scanning

Code scanning is a GitHub feature that allows you to automatically scan your code for security vulnerabilities. Code scanning works by integrating with third-party static analysis tools as well as Githubs CodeQL, which analyze your code for potential security issues such as buffer overflows, cross-site scripting (XSS) vulnerabilities, and SQL injection vulnerabilities. Code scanning can be set up to run automatically as part of your continuous integration (CI) pipeline, which helps catch vulnerabilities early in the development process.  The files these scans produce is in "SARIF" (Static Analysis Results Interchange Format ) which is a industry standard format for security scanning tools which is also what the Security tab in Github expects when you upload results to it.

- Github developed its own code-scanning software called CodeQL which they have their own actions for so you can set it up pretty quickly with out of the box functionality for some interpreted languages like Python, Javascript, and Ruby and it automatically detects supported languages and puts those into the workflow for you.  For those languages that need to be compiled, you can still run the tool against them but you need to have a custom build step in your workflow before you analyse it. The short story of what it does is make a relational database out of your code and runs queries against it to detect a variety of potential issues then uploads the its findings to your security tab. (link to CodeQL docs [here](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql))

## Secret scanning

Secret scanning is a GitHub feature that helps prevent secrets such as API keys and access tokens from being accidentally committed to your repository. Secret scanning works by scanning your repositories for potential secrets using regular expressions, and notifying you if any are found. If a potential secret is found, you will receive an email notification with details on how to remove the secret from your repository. (Docs for secret scanning [here](https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/about-secret-scanning))

- If you have Github Enterprise, you can also create your own patterns for the secret scanning to pick up.

## Dependabot alerts

Dependabot alerts are notifications that GitHub sends when vulnerabilities are discovered in software dependencies used by your repositories. Dependabot alerts work by scanning your repositories for known vulnerabilities in dependencies, and sending you an email notification if any are found. Dependabot alerts can be set up to automatically create pull requests that update your dependencies to the latest secure version.

## Dependabot security updates

Dependabot security updates are automatic pull requests that update your dependencies to the latest secure version when vulnerabilities are discovered. Dependabot security updates work by scanning your repositories for known vulnerabilities in dependencies, and automatically creating a pull request that updates the dependency to the latest secure version. Dependabot security updates can be set up to automatically merge the pull request if all tests pass, which helps ensure that your code is always up-to-date and secure.

## Exercise 1

 For this first one, we will explore a bit more of the code-scanning side of Github security using CodeQL.  As mentioned previously, CodeQL has some good default workflows you can setup to help you get started with code-scanning.  You can either use that or a tool we refactored into Go based off of [mario-campos/gh-code-scanning](https://github.com/mario-campos/gh-code-scanning) which does basically the same thing except its cooler and it lives [here](https://github.com/liatrio/csgo) (still a work in progress).

1. Create a repository that includes some code from one of the many CodeQl supported interpreted languages.
2. Using the tool of your choice, enable code-scanning on your repository as well as create a basic workflow to start doing some code scanning with.
