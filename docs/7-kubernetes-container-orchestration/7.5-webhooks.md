# 7.5 Admission Webhooks

Kubernetes offers developers admission webhooks to validate and mutate resources before they are provisioned and stored in etcd. In this section we will be looking at validating and mutating admission webhooks. 

## Validating and Mutating Webhooks 
Let's say as a developer you needed to create a new pod on your cluster. For this example let's use a simple nginx pod definition. 

```
apiVersion: v1
kind: Pod
metadata: 
    name: nginx-example
spec:
    containers: 
        - image: nginx:latest
          name: nginx-example
```

How does this pod actually get created? Well when we apply our pod definition, our kubelet sends an api request to the kube api-server. Our resource is then authenticated with the kube api-server and then the pod can persist in etcd. However, what if there are problems with this pod? What if a cluster admin wants to require that all pod created in a namespace must have specific labels, or that they need resource defaults associated with them? As our nginx pod stands now we would not want to actually create this pod in our org's cluster. So how can we enforce policy to catch these errors and others? 

![](img7/api-lifecycle.svg ':class=img-center')

Looking at the picture above, we see that Kubernetes gives us a chance to interact with a resource before it is persisted and provisoned. We can achieve this by using validating and mutating webhooks. A mutating webhook allows us to make changes to a resource before it is persisted in etcd. For example, if we pushed up a pod without resource defaults, our mutating webhook would catch this and inject a resource block (requests and limits for memory and cpu) into our pod. A validating webhook does not let us edit resources. Instead it gives us the ability to enforce policy over a cluster. For instance, we could have a requirment in our validating webhook requiring all namespaced pods have the label `foo:bar` in their metadata, and if they don't we reject the resource. 

Mutating and validating webhooks are used in conjunction to enforce policy. The mutating webhook happens first so we can inject any missing fields that the validating webhook requires before actually getting to the validating webhook step. These are both custom webhook configurations. As cluster admin we would write our policy code in whatever language we prefer (Golang and Python are usually the go to).  

