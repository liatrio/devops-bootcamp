# 7.5 Admission Webhooks

Kubernetes offers admission webhooks to validate and mutate resources before they are provisioned and stored in etcd. In this section we will examine the two types of admission webhooks: validating and mutating. 

## Validating and Mutating Webhooks 
Take a scenario where you are a developer looking to create a new pod on your cluster. For this example let's use a simple nginx pod definition. 

```
apiVersion: v1
kind: Pod
metadata: 
    name: nginx-example
spec:
    containers: 
        - image: nginx:latest
          name: nginx-example
```

How does this pod actually get created? This pod is created when the pod definition is applied- resulting in the kubelet sending an api request to the kube-apiserver, where the resource is authenticated, enabling the pod to persist in etcd. However, what if there are problems with this pod? What if a cluster admin wants to require that all pods created in a namespace must have specific labels, or that they need resource defaults associated with them? As our nginx pod stands now we would not want to actually create this pod in our org's cluster. So how can we enforce policy to catch these errors and others? 

![](img7/api-lifecycle.svg ':class=img-center')

Looking at the picture above, we see that Kubernetes gives us a chance to interact with a resource before it is persisted and provisioned. We can achieve this by using validating and mutating webhooks. A mutating webhook allows us to make changes to a resource before it is persisted in etcd. For example, if we pushed up a pod without resource defaults, our mutating webhook would catch this and inject a resource block (requests and limits for memory and cpu) into our pod. A validating webhook does not let us edit resources. Instead it gives us the ability to enforce policy over a cluster. For instance, we could have a requirement in our validating webhook requiring all namespaced pods have the label `foo:bar` in their metadata, and if they don't we reject the resource. 

Mutating and validating webhooks are used in conjunction to enforce policy. The mutating webhook happens first so we can inject any missing fields that the validating webhook requires before actually getting to the validating webhook step. These are both custom webhook configurations. As cluster admin we would write our policy code in whatever language we prefer (Golang and Python are the most widely used).  