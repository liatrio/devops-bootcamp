# Azure Virtual Machine Scale Sets (VMSS)

In this section we will demonstrate how Virtual Machine Scale Sets (VMSS) work in Azure. We will build upon the learnings from previous sections and use a VMSS to host our simple website. Web assets will be hosted from shared storage in an Azure Storage account. We will then generate some artificual load to make sure scaling is working as expected.

## Create an VMSS and serve content from an Azure Storage Account

1. Log into Azure CLI and select the correct subscription

```
az login
az acccount set --subscription "liatrio-sandbox"
```

2. Create resource group for the VMSS and associated resources.

```
RESOURCE_GROUP=RG-brent-bootcamp
LOCATION=westus
az group create --name $RESOURCE_GROUP --location $LOCATION
```

3. Create a new storage account.

```
STORAGE_ACCOUNT=brentbasicwebsite123
az storage account create \
  --name $STORAGE_ACCOUNT \
  --resource-group $RESOURCE_GROUP \
  --location $LOCATION
```

4. Get the storage access key for the storage account.

```
STORAGE_KEY=$(az storage account keys list --resource-group $RESOURCE_GROUP --account-name $STORAGE_ACCOUNT --query "[0].value" | tr -d '"')
```

5. Create a file share in the storage account.

```
SHARE_NAME=brent-web-fileshare
az storage share create \
  --name $SHARE_NAME \
  --quota 1 \
  --account-name $STORAGE_ACCOUNT \
  --account-key $STORAGE_KEY
```

6. Create a simple Node.js app that returns the hostname of the VM (same one we used in section 6.3.2).

```
mkdir /tmp/webapp/
cat <<EOF > /tmp/webapp/index.js
var express = require('express')
var app = express()
var os = require('os');
app.get('/', function (req, res) {
  res.send('DevOps Bootcamp sample app running on host ' + os.hostname() + '!')
})
app.listen(3000, function () {
  console.log('Test app listening on port 3000!')
})
EOF
```

7. Build the Node.js app locally first. Feel free to launch it locally and make sure it works.

```
cd /tmp/webapp
npm init --yes
npm install express -y
```

7. Upload the Node.js app to Azure file share we created in step 5.

```
az storage file upload-batch \
  --account-key $STORAGE_KEY \
  --account-name $STORAGE_ACCOUNT \
  --destination $SHARE_NAME --source /tmp/webapp
```

8. Update the cloud-init script for VMSS. It now will mount Azure Files share containing our Node.js app and launch from that mount.

```
cat <<EOF > /tmp/cloud-init-vmss.txt
#cloud-config
package_update: true
package_upgrade: true
packages:
  - nginx
  - nodejs
  - npm
write_files:
  - owner: www-data:www-data
  - path: /etc/nginx/sites-available/default
    content: |
      server {
        listen 80;
        location / {
          proxy_pass http://localhost:3000;
          proxy_http_version 1.1;
          proxy_set_header Upgrade \$http_upgrade;
          proxy_set_header Connection keep-alive;
          proxy_set_header Host \$host;
          proxy_cache_bypass \$http_upgrade;
        }
      }
runcmd:
  - mkdir "/mnt/webapp"
  - 'mount -t cifs //$STORAGE_ACCOUNT.file.core.windows.net/$SHARE_NAME /mnt/webapp -o vers=3.0,username=$STORAGE_ACCOUNT,password=$STORAGE_KEY,dir_mode=0755,file_mode=0664'
  - service nginx restart
  - cd "/mnt/webapp"
  - nodejs index.js
EOF
```

9. Create VMSS using our custom cloud-init script. We can use the same SSH keys you generated in section 6.3.2.

```
VMSS_NAME=VMSS-brent-bootcamp
az vmss create \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --image UbuntuLTS \
  --vm-sku Standard_B1s \
  --upgrade-policy-mode automatic \
  --admin-username azureuser \
  --ssh-key-values /tmp/id_rsa.pub \
  --instance-count 2 \
  --custom-data /tmp/cloud-init-vmss.txt
```

**(note: it make take a few minutes for cloud-init to install packages and perform updates, especially with small instance sizes!)**

10. When the VMSS was created, it automatically created a load balancer instance. Let's add a load balancing rule to it so we can reach our Node.js app.

```
az network lb rule create \
  --resource-group $RESOURCE_GROUP \
  --name myLoadBalancerRuleWeb \
  --lb-name "${VMSS_NAME}LB" \
  --backend-pool-name "${VMSS_NAME}LBBEPool" \
  --backend-port 80 \
  --frontend-ip-name loadBalancerFrontEnd \
  --frontend-port 80 \
  --protocol tcp
```

11. Get the public IP for load balancer and make sure we can reach the Node.js app. You should see responses from both instances in the scale set.

```
PUBLIC_IP=$(az network public-ip show \
    --resource-group $RESOURCE_GROUP \
    --name "${VMSS_NAME}LBPublicIP" \
    --query [ipAddress] \
    --output tsv)
```

```
curl -w '\n' http://$PUBLIC_IP
```

12. Create autoscaling profile.

```
AUTOSCALE_PROFILE=brentautoscaleprofile123
az monitor autoscale create \
  --resource-group $RESOURCE_GROUP \
  --resource $VMSS_NAME \
  --resource-type Microsoft.Compute/virtualMachineScaleSets \
  --name $AUTOSCALE_PROFILE \
  --min-count 2 \
  --max-count 4 \
  --count 2
```

13. Create the scale-in and scale-out rules based on CPU usage.

```
az monitor autoscale rule create \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name $AUTOSCALE_PROFILE \
  --condition "Percentage CPU > 70 avg 5m" \
  --scale out 1
```

```
az monitor autoscale rule create \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name $AUTOSCALE_PROFILE \
  --condition "Percentage CPU < 30 avg 5m" \
  --scale in 1
```

14. Confirm how many instances are running now.

```
az vmss list-instances \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --output table
```

15. Get the connection info for the individual instances in the scale set.

```
az vmss list-instance-connection-info \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME
```

16. Log into each instance and generate some load so we can trigger the scale-out rule. The public IP is the same from step 11, but the port numbers will be different by instance. A simple utilty called "stress" will be used to generate our fake load.

```
ssh -i /tmp/id_rsa azureuser@$PUBLIC_IP -p 50001

sudo apt-get -y install stress ; sudo stress --cpu 10 --timeout 420 &

ssh -i /tmp/id_rsa azureuser@public_IP -p 50001

sudo apt-get -y install stress ; sudo stress --cpu 10 --timeout 420 &
```

**(note: after starting the stress command, you can use the top command to see the CPU load increase)**

17. Confirm if a new instance has been added after about 5 minutes. After waiting for the stress test to finish and another 5 minutes, the scale set should return to 2 instances.

```
az vmss list-instances \
  --resource-group $RESOURCE_GROUP \
  --name $VMSS_NAME \
  --output table
```

18. Cleanup.

```
az group delete -n $RESOURCE_GROUP
```