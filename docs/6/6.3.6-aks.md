# Azure Kubernetes Service (AKS)

As eluded to in the previous section, ACI has limitations in terms of managing the deployment of many different containers. [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/en-ca/services/kubernetes-service/) is a container orchestration platform that addresses the needs of enterprise applications consisting of many containers that interoperate with each other. In this section we will take our simple Node.js application that we containerized in section 6.3.5 and deploy it to AKS.

## Create an AKS cluster and deploy our Node.js application

1. Log into Azure CLI and select the correct subscription

```
az login
az acccount set --subscription "liatrio-sandbox"
```

2. Create resource group for AKS and associated resources.

```
RESOURCE_GROUP=RG-brent-bootcamp
LOCATION=westus
az group create --name $RESOURCE_GROUP --location $LOCATION
```

3. Follow steps 1 through 12 from section 6.3.6, we will use the same container image, ACR instance and service principal for the next steps.

4. Create the AKS cluster.

```
CLUSTER_NAME=AKS-brent-devopsbootcamp
az aks create \
  --resource-group $RESOURCE_GROUP \
  --name $CLUSTER_NAME \
  --node-count 1 \
  --node-vm-size Standard_B2s \
  --generate-ssh-keys
```

5. Get credentials for your new AKS cluster.

```
az aks get-credentials \
  --resource-group $RESOURCE_GROUP \
  --name $CLUSTER_NAME
```

6. Use kubectl and confirm you can manage your new AKS cluster. You can also use Azure Portal to explore cluster resources.

```
kubectl get nodes
```

7. Create a namespace to install our Node.js application.

```
NAMESPACE=devops-bootcamp
kubectl create namespace $NAMESPACE
```

8. Create registry secret in the namespace so images can be pulled from ACR.

```
SECRET_NAME=acr-secret
kubectl create secret docker-registry $SECRET_NAME \
  --namespace $NAMESPACE \
  --docker-server=$DOCKER_SERVER \
  --docker-username=$DOCKER_USERNAME \
  --docker-password=$DOCKER_PASSWORD
```

10. Deploy using Kubernetes manifests. In the interest of simplicity, we will expose our application via a Service of type LoadBalancer. Normally we would expose such applications via an Ingress resource.

```
cat <<EOF > /tmp/aks-bootcamp.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: aks-bootcamp
  namespace: $NAMESPACE
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aks-bootcamp
  template:
    metadata:
      labels:
        app: aks-bootcamp
    spec:
      nodeSelector:
        "beta.kubernetes.io/os": linux
      containers:
      - name: aks-bootcamp
        image: $DOCKER_SERVER/aci-bootcamp:v1
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 250m
            memory: 256Mi
        ports:
        - containerPort: 3000
      imagePullSecrets:
      - name: $SECRET_NAME
---
apiVersion: v1
kind: Service
metadata:
  name: aks-bootcamp
  namespace: $NAMESPACE
spec:
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  selector:
    app: aks-bootcamp
EOF
```

```
kubectl apply -f /tmp/aks-bootcamp.yaml
```

```
kubectl get pods -n $NAMESPACE
```

11. Get the External IP for the Load Balancer and test application.

```
kubectl get service -n devops-bootcamp
```

12. As always, we cleanup resources to save cost.

```
az group delete -n $RESOURCE_GROUP
az ad sp delete --id $DOCKER_USERNAME
```
