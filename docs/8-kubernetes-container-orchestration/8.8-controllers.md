---
docs/8-kubernetes-container-orchestration/8.8-controllers.md:
  category: Container Orchestration
  estReadingMinutes: 15
  exercises:
  - name: Setup
    description: Set up the environment for admission webhooks by deploying a KIND cluster with Admission Controller enabled, installing cert-manager, and creating a validation namespace, root CA, and self-signed certificate.
    estMinutes: 60
    technologies:
    - Kubernetes
    - KIND
    - cert-manager
---

# 8.8 Controllers

## Controllers in Kubernetes

One of the core principles of Kubernetes is the maintenence of a desired state of your applications and infrastructure. Controllers are one of the critical components that make this possible. They act as the “watchers” and “correctors” in the Kubernetes ecosystem, continuously monitoring resources to ensure that the real-time state aligns with the desired state you've defined.

Due the the declarative nature of Kubernetes manifests, every time you deploy something in Kubernetes—whether it's a set of pods, a load balancer, or a job—you’re effectively telling Kubernetes what you want the end result to look like. Controllers make this happen by performing ongoing checks on the cluster’s state and taking corrective action when discrepancies are found. This could mean restarting a failed pod, scaling up replicas, or re-creating a missing resource.

You can read more about controllers [here](https://kubernetes.io/docs/concepts/architecture/controller/).

## Controllers and CRDs (Custom Resource Definitions)

Although Kubernetes comes with numerous built-in controllers that handle core functionalities—like maintaining replica counts, managing rollouts, and ensuring nodes are healthy—one of the most powerful use cases for controllers is actually to extend Kubernetes with Custom Resource Definitions (CRDs). CRDs allow developers to create custom resources that Kubernetes doesn’t natively support, and custom controllers that then manage these new resource types, bringing them into the Kubernetes control loop. This means that by writing your own controllers, you can leverage Kubernetes to automate virtually any process or infrastructure task specific to your environment, from monitoring external services to managing custom application lifecycles.

If you've been working through the bootcamp, you've already been exposed to both CRDs and custom controllers. In the first exercise of chapter 8.6, Webhooks, you were tasked with setting up a basic admission webhook, which required installing cert-manager. `cert-manager` is a powerful tool that combines a set of custom resource definitions (CRDs) with a custom controller to automate the issuance, renewal, and management of TLS certificates that webhooks require to securely interact with the Kubernetes API server. By leveraging CRDs like Certificate, Issuer, and ClusterIssuer, cert-manager enables you to declare and manage certificates directly within Kubernetes, removing the need for manual intervention in obtaining and maintaining certificates. This automation is not only convenient but essential in high-scale environments where TLS certificates need frequent renewal to ensure secure connections across applications and services.

The custom controller within cert-manager works in tandem with these CRDs, continuously monitoring the cluster to issue, validate, and renew certificates as needed. This example illustrates the true power of custom controllers and CRDs in Kubernetes: they allow you to extend Kubernetes' native functionality, transforming it from a platform primarily for container orchestration to a versatile tool for managing infrastructure components. 

You can read more about custom resources [here](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/).

## Creating a simple custom controller

That being said, custom controllers aren’t limited to only managing custom resources. They can also be designed to interact with and manage native Kubernetes resources, enabling a wide range of powerful functionalities. By observing and modifying built-in resources like Pods, Deployments, or Services, custom controllers allow you to implement advanced automation, enforce policies, enhance security, and streamline operational workflows directly within Kubernetes.

?> Your controller will be using the `client-go` library provided by Kubernetes to communicate with the Kubernetes API server and manage resources. You can learn more about client-go [here]()

In this exercise, you are responsible for creating a custom controller that will monitor the cluster, looking for pods in a particular namespace with a particular label. If a pod is found in the namespace with that label, your controller should attach an annotation to said pod.

### Setup
___
- If you don't have it already install `k3d`
```shell
curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
```

- Verify you have at least v1.30 of `k3s` installed
```shell
➜  devops-bootcamp ✗ k3d --version
k3d version v5.7.3
k3s version v1.30.3-k3s1 (default)
```

- Create a new cluster  `unset KUBECONFIG; k3d cluster create <cluster-name>`


### Exercise 1
___

1. Clone the [bootcamp repository](https://github.com/liatrio/devops-bootcamp) if you haven't already, and navigate to the `examples/ch8/controllers` folder, where you will find a skeleton file for a custom controller

1. Create a directory *pod-controller-module*

3. Move a copy of the skeleton file to your *pod-controller-module* directory, navigate there, and run `go mod init .` to initialize the directory as a go module

4. Change the skeleton file so that the controller will: 
- Look for pods in a 
