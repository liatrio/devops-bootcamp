---
docs/11-application-development/11.1-layers.md:
  category: Software Development
  estReadingMinutes: 30
  exercises:
    -
      name: Compare tightly coupled vs layered architecture
      description: Run both example applications, examine their structure, and understand the architectural differences.
      estMinutes: 60
      technologies:
      - Python
      - Flask
    -
      name: Refactor storage backend from in-memory to SQLite
      description: Switch the data storage in both examples from in-memory to SQLite, comparing the effort required in tightly coupled vs layered implementations.
      estMinutes: 90
      technologies:
      - Python
      - Flask
      - SQLite
---
# Layered Architecture

Layered architecture is a software design pattern that organizes code into distinct layers, each with a specific responsibility. This separation of concerns makes applications easier to understand, test, and maintain. The pattern was popularized by Martin Fowler and has become a fundamental approach in enterprise application development.

## What is Layered Architecture?

In a layered architecture, an application is divided into horizontal layers:

- **Presentation Layer**: Handles user interaction and displays information (e.g., web routes, API endpoints, UI components)
- **Business Logic Layer**: Contains the core application logic, rules, and workflows (e.g., validation, calculations, business rules)
- **Data Access Layer**: Manages data storage and retrieval (e.g., database queries, file I/O, external API calls)

Each layer should only interact with the layer directly below it. This creates clear boundaries and dependencies.

### Key Benefits

**Maintainability**: Changes to one layer typically don't require changes to other layers. For example, switching from one database to another only affects the data access layer.

**Testability**: Each layer can be tested independently. Business logic can be tested without a real database by using mock data access layers.

**Reusability**: Business logic can be reused by different presentation layers (web UI, mobile app, API).

**Clarity**: Developers can quickly understand what each part of the code does and where to make changes.

## The Problem: Tightly Coupled Code

Let's start by understanding the problem that layered architecture solves. Consider a simple user management application where all functionality lives in a single file:

```python
# Everything in one place
@app.route("/users", methods=["GET"])
def list_users():
    # Presentation, business logic, and data access all mixed together
    users = USERS  # Direct access to data structure
    return jsonify(users)

@app.route("/users", methods=["POST"])
def create_user():
    # Route handler contains validation, business rules, and data manipulation
    payload = request.get_json() or {}
    name = payload.get("name")
    if not name:  # Validation in route
        return jsonify({"error": "name required"}), 400
    user = {"id": NEXT_ID, "name": name}  # Direct data manipulation
    USERS.append(user)  # Direct data access
    return jsonify(user), 201
```

### Problems with This Approach

1. **Hard to Test**: You can't test validation logic without involving the web framework
2. **Hard to Change**: Switching from in-memory storage to a database requires editing route handlers
3. **Hard to Reuse**: Business logic is embedded in routes and can't be used by other interfaces
4. **Hard to Understand**: Everything is mixed together, making it difficult to see what the code does (I know in this small example it is simple, but imagine this in a larger codebase)

## The Solution: Layered Architecture

Now let's see how layered architecture solves these problems:

### Presentation Layer (Routes)

```python
# presentation/routes.py
@bp.route("/users", methods=["GET"])
def list_users():
    return jsonify(get_users())  # Delegates to business layer

@bp.route("/users", methods=["POST"])
def add_user():
    payload = request.get_json() or {}
    try:
        user = create_user(payload)  # Delegates to business layer
    except ValueError as e:
        return jsonify({"error": str(e)}), 400
    return jsonify(user), 201
```

The presentation layer is thin—it only handles HTTP concerns (parsing requests, formatting responses) and delegates to the business layer.

### Business Logic Layer (Services)

```python
# services/user_service.py
def get_users():
    return repo.get_all()  # Delegates to data layer

def create_user(payload):
    name = payload.get("name")
    if not name or not isinstance(name, str):
        raise ValueError("name required")  # Business validation
    return repo.add({"name": name})  # Delegates to data layer
```

The business layer contains all validation and business rules. It knows nothing about HTTP or databases.

### Data Access Layer (Repository)

```python
# data/in_memory_repo.py
USERS = [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
NEXT_ID = 3

def get_all():
    return USERS.copy()

def add(user):
    global NEXT_ID
    u = {"id": NEXT_ID, "name": user["name"]}
    NEXT_ID += 1
    USERS.append(u)
    return u
```

The data layer handles storage. It could be in-memory, a database, or an external API—the business and presentation layers don't need to know.

## Hands-On Exercise

We've provided two working examples to demonstrate these concepts:

### Example 1: Tightly Coupled Application

A single-file Flask application where routes, business logic, and data access are all mixed together. This represents a typical quick prototype or small script.

**Location**: `examples/ch11/example1/`

### Example 2: Layered Application

The same application refactored into a layered architecture with clear separation between presentation, business logic, and data access.

**Location**: `examples/ch11/example2/`

### Running the Examples

Both examples are fully functional Flask applications with the same API behavior. Follow the README files in each example directory to:

1. Set up a Python virtual environment
2. Install dependencies
3. Run the application
4. Run the tests

Try making requests to both applications and verify they behave identically:

```bash
# List users
curl http://127.0.0.1:5000/users

# Create a user
curl -X POST http://127.0.0.1:5000/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Charlie"}'
```

### Exercise: Change the Storage Backend

Both examples currently use in-memory storage. Your task is to switch both applications to use SQLite for persistent storage.

**In Example 1 (Tightly Coupled)**:

You'll need to:
1. Add SQLite imports and connection logic
2. Modify the `list_users()` route to query the database
3. Modify the `create_user()` route to insert into the database
4. Add table creation logic
5. Handle database errors

This requires editing the core route handlers and thoroughly retesting.

**In Example 2 (Layered)**:

You'll need to:
1. Create a new data access module `data/sqlite_repo.py` that implements the same interface as `in_memory_repo.py` but uses SQLite.
2. Switch data layer to use the new data module (this should be a one liner)

That's it! The presentation and business layers remain completely unchanged. The SQLite repository implementation is already provided.

## Comparing the Results

After completing both changes:

- **Example 1** required modifying route handlers, mixing database code with HTTP code
- **Example 2** cutover required a single line change

This demonstrates the power of layered architecture: changes are isolated to the appropriate layer, and other layers don't need to know about the implementation details.

### What Makes This Work?

The key is the **repository interface**. Both `in_memory_repo.py` and `sqlite_repo.py` provide the same functions:

- `get_all()` - returns a list of user dictionaries
- `add(user)` - adds a user and returns the created user dictionary

The business and presentation layers depend on this interface, not on the specific implementation. This is an example of **dependency inversion** - depending on abstractions rather than concrete implementations.

## When to Use Layered Architecture

Layered architecture is excellent for:

- **Business applications** with clear separation between UI, logic, and data
- **APIs** that need to support multiple clients
- **Applications that will grow** in size and complexity
- **Team projects** where different developers work on different concerns

You might skip layered architecture for:

- **Quick prototypes** or scripts that won't be maintained
- **Very simple applications** with minimal logic (though even simple apps can benefit)

## Best Practices

1. **Keep layers thin**: Each layer should do one thing well
2. **Avoid leaking abstractions**: Don't pass database objects through to the presentation layer
3. **Use consistent interfaces**: Repository functions should have clear, predictable contracts
4. **Test each layer independently**: Unit test business logic without databases; integration test with real data stores
5. **Document layer boundaries**: Make it clear what each layer is responsible for

## Additional Patterns

Layered architecture is foundational, but there are related patterns to explore:

- **Hexagonal Architecture (Ports and Adapters)**: Similar to layers but emphasizes the business logic at the core
- **Clean Architecture**: Robert Martin's approach emphasizing dependency inversion
- **Domain-Driven Design**: Organizing code around business domains rather than technical layers
- **MVC (Model-View-Controller)**: A specific type of layered architecture for UI applications

Each pattern has trade-offs, but they all share the goal of separating concerns and making code more maintainable.

## Exercise 3 Drill it home

Try making the following changes to the layered example to deepen your understanding :

1. Add a `get_user_by_id(user_id)` function to all three layers
2. Add a `delete_user(user_id)` function
3. Create a third repository implementation that uses a JSON file
4. Add more business logic (e.g., name must be at least 2 characters)
5. Write unit tests for the service layer that mock the repository

## Conclusion

Layered architecture is a proven pattern for building maintainable applications. By separating presentation, business logic, and data access into distinct layers, you create code that is easier to understand, test, and modify.

The hands-on examples demonstrate this concretely: changing storage backends in a layered application is trivial, while the same change in tightly coupled code requires significant refactoring.

## Deliverables

- What are the three primary layers in a layered architecture, and what is each responsible for?
- Why is it easier to change the data storage in a layered application compared to a tightly coupled application?
- What is a repository interface, and why is it important?
- When would you choose not to use layered architecture?
- How does layered architecture improve testability?
