# Design Patterns

Design patterns are reusable solutions to common problems that occur in software design. They represent best practices evolved over time by experienced developers and provide a shared vocabulary for discussing software architecture.

## Why Design Patterns Matter

Understanding design patterns helps you:

- **Write maintainable code**: Patterns guide you toward structures that are easier to modify and extend
- **Communicate effectively**: Patterns provide a common language for discussing design decisions with other developers
- **Avoid reinventing the wheel**: Patterns capture proven solutions to recurring problems
- **Build on experience**: Patterns encode collective wisdom from decades of software development

## Foundation: SOLID Principles

Before diving into specific patterns, it's essential to understand the SOLID principles. These five principles form the foundation for writing clean, maintainable object-oriented code:

| Principle | Description |
| --------- | ----------- |
| **S**ingle Responsibility | A class should have only one reason to change |
| **O**pen/Closed | Software entities should be open for extension but closed for modification |
| **L**iskov Substitution | Subtypes must be substitutable for their base types |
| **I**nterface Segregation | Clients should not be forced to depend on interfaces they don't use |
| **D**ependency Inversion | Depend on abstractions, not concretions |

These principles work together to create code that is modular, testable, and resilient to change. The [SOLID Principles](11-application-development/11.2.1-solid-principles.md) section explores each principle in depth with practical Python examples.

## Pattern Categories

Design patterns are typically organized into three categories:

### Creational Patterns

Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

- **Factory Method**: Define an interface for creating objects, but let subclasses decide which class to instantiate
- **Abstract Factory**: Provide an interface for creating families of related objects
- **Builder**: Separate the construction of complex objects from their representation
- **Singleton**: Ensure a class has only one instance and provide a global point of access
- **Prototype**: Create new objects by copying an existing object

### Structural Patterns

Structural patterns deal with object composition, creating relationships between objects to form larger structures.

- **Adapter**: Convert the interface of a class into another interface clients expect
- **Bridge**: Decouple an abstraction from its implementation
- **Composite**: Compose objects into tree structures to represent part-whole hierarchies
- **Decorator**: Attach additional responsibilities to objects dynamically
- **Facade**: Provide a unified interface to a set of interfaces in a subsystem
- **Proxy**: Provide a surrogate or placeholder for another object

### Behavioral Patterns

Behavioral patterns deal with communication between objects, defining how objects interact and distribute responsibility.

- **Observer**: Define a one-to-many dependency so that when one object changes state, all dependents are notified
- **Strategy**: Define a family of algorithms, encapsulate each one, and make them interchangeable
- **Command**: Encapsulate a request as an object
- **State**: Allow an object to alter its behavior when its internal state changes
- **Template Method**: Define the skeleton of an algorithm, deferring some steps to subclasses

## How Patterns Connect

Design patterns don't exist in isolation. They often work together and build upon SOLID principles:

```text
┌─────────────────────────────────────────────────────────────┐
│                     SOLID Principles                        │
│  (Foundation for all good object-oriented design)           │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Design Patterns                          │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ Creational  │  │ Structural  │  │    Behavioral       │  │
│  │             │  │             │  │                     │  │
│  │ Factory     │  │ Adapter     │  │ Observer            │  │
│  │ Builder     │  │ Decorator   │  │ Strategy            │  │
│  │ Singleton   │  │ Facade      │  │ Command             │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              Architectural Patterns                         │
│  (Layered Architecture, MVC, Microservices, etc.)           │
└─────────────────────────────────────────────────────────────┘
```

## Getting Started

Start with the [SOLID Principles](11-application-development/11.2.1-solid-principles.md) section to build a strong foundation. Each principle includes:

- Clear explanation of the concept
- Python code examples showing before/after transformations
- Practical guidance on when and how to apply the principle

Once you understand SOLID, you'll find that design patterns become much more intuitive—they're natural applications of these principles to specific problems.

## Additional Resources

- **"Design Patterns: Elements of Reusable Object-Oriented Software"** by the Gang of Four - The classic reference
- **"Clean Code"** by Robert C. Martin - Practical guidance on writing maintainable code
- **"Refactoring"** by Martin Fowler - How to improve existing code structure
- [Refactoring Guru](https://refactoring.guru) - Visual explanations of patterns
