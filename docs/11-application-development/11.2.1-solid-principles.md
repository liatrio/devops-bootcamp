---
docs/11-application-development/11.2.1-solid-principles.md:
  category: Software Development
  estReadingMinutes: 45
  exercises:
    -
      name: Refactor a class to follow SRP
      description: Take a provided monolithic class and refactor it into multiple classes, each with a single responsibility.
      estMinutes: 45
      technologies:
      - Python
    -
      name: Apply Open/Closed Principle to payment processing
      description: Extend a payment system to support new payment methods without modifying existing code.
      estMinutes: 60
      technologies:
      - Python
    -
      name: Implement Dependency Injection
      description: Refactor tightly coupled code to use dependency injection, making it testable and flexible.
      estMinutes: 45
      technologies:
      - Python
---
# SOLID Principles

The SOLID principles are five design principles that help developers create maintainable, flexible, and understandable software. Coined by Robert C. Martin (Uncle Bob), these principles have become fundamental to object-oriented design.

## Overview

| Principle | Full Name | Key Idea |
| --------- | --------- | -------- |
| **S** | Single Responsibility | One class, one job |
| **O** | Open/Closed | Extend without modifying |
| **L** | Liskov Substitution | Subtypes are substitutable |
| **I** | Interface Segregation | Small, focused interfaces |
| **D** | Dependency Inversion | Depend on abstractions |

## Single Responsibility Principle (SRP)

> "A class should have only one reason to change."

The Single Responsibility Principle states that a class should have only one job or responsibility. When a class handles multiple concerns, changes to one concern can inadvertently affect others.

### The Problem: A Class Doing Too Much

Consider a user management class that handles multiple responsibilities:

```python
# BAD: This class has multiple responsibilities
class UserManager:
    def __init__(self, db_connection):
        self.db = db_connection

    def create_user(self, username, email, password):
        # Validation logic
        if not username or len(username) < 3:
            raise ValueError("Username must be at least 3 characters")
        if "@" not in email:
            raise ValueError("Invalid email format")
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters")

        # Password hashing
        import hashlib
        hashed = hashlib.sha256(password.encode()).hexdigest()

        # Database operations
        self.db.execute(
            "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
            (username, email, hashed)
        )

        # Email notification
        import smtplib
        server = smtplib.SMTP('smtp.example.com', 587)
        server.sendmail(
            'noreply@example.com',
            email,
            f'Welcome {username}! Your account has been created.'
        )
        server.quit()

        # Logging
        with open('user_log.txt', 'a') as f:
            f.write(f"Created user: {username}\n")
```

**Problems with this approach:**
- Changes to email logic require modifying the UserManager class
- You can't test user creation without an SMTP server
- Validation rules are buried inside the creation method
- The class has at least 5 reasons to change (validation, hashing, database, email, logging)

### The Solution: Separate Responsibilities

```python
# GOOD: Each class has a single responsibility

class UserValidator:
    """Handles all user validation logic."""

    def validate_username(self, username: str) -> None:
        if not username or len(username) < 3:
            raise ValueError("Username must be at least 3 characters")

    def validate_email(self, email: str) -> None:
        if "@" not in email:
            raise ValueError("Invalid email format")

    def validate_password(self, password: str) -> None:
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters")

    def validate_user(self, username: str, email: str, password: str) -> None:
        self.validate_username(username)
        self.validate_email(email)
        self.validate_password(password)


class PasswordHasher:
    """Handles password hashing."""

    def hash(self, password: str) -> str:
        import hashlib
        return hashlib.sha256(password.encode()).hexdigest()


class UserRepository:
    """Handles database operations for users."""

    def __init__(self, db_connection):
        self.db = db_connection

    def save(self, username: str, email: str, hashed_password: str) -> dict:
        self.db.execute(
            "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
            (username, email, hashed_password)
        )
        return {"username": username, "email": email}


class EmailService:
    """Handles sending emails."""

    def __init__(self, smtp_host: str, smtp_port: int):
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port

    def send_welcome_email(self, email: str, username: str) -> None:
        import smtplib
        server = smtplib.SMTP(self.smtp_host, self.smtp_port)
        server.sendmail(
            'noreply@example.com',
            email,
            f'Welcome {username}! Your account has been created.'
        )
        server.quit()


class UserLogger:
    """Handles user-related logging."""

    def __init__(self, log_file: str):
        self.log_file = log_file

    def log_creation(self, username: str) -> None:
        with open(self.log_file, 'a') as f:
            f.write(f"Created user: {username}\n")


class UserService:
    """Coordinates user creation using specialized classes."""

    def __init__(
        self,
        validator: UserValidator,
        hasher: PasswordHasher,
        repository: UserRepository,
        email_service: EmailService,
        logger: UserLogger
    ):
        self.validator = validator
        self.hasher = hasher
        self.repository = repository
        self.email_service = email_service
        self.logger = logger

    def create_user(self, username: str, email: str, password: str) -> dict:
        # Each step delegates to a specialized class
        self.validator.validate_user(username, email, password)
        hashed_password = self.hasher.hash(password)
        user = self.repository.save(username, email, hashed_password)
        self.email_service.send_welcome_email(email, username)
        self.logger.log_creation(username)
        return user
```

**Benefits of this approach:**
- Each class can be tested independently
- Changes to email logic only affect `EmailService`
- Validation rules can be reused elsewhere
- Easy to swap implementations (e.g., different logging backends)

## Open/Closed Principle (OCP)

> "Software entities should be open for extension but closed for modification."

You should be able to add new functionality without changing existing code. This is typically achieved through abstraction and polymorphism.

### The Problem: Modifying Existing Code for New Features

```python
# BAD: Adding new payment types requires modifying this class
class PaymentProcessor:
    def process_payment(self, payment_type: str, amount: float) -> str:
        if payment_type == "credit_card":
            # Credit card processing logic
            return f"Processed ${amount} via credit card"
        elif payment_type == "paypal":
            # PayPal processing logic
            return f"Processed ${amount} via PayPal"
        elif payment_type == "bitcoin":
            # Bitcoin processing logic
            return f"Processed ${amount} via Bitcoin"
        # Every new payment type requires adding another elif here!
        else:
            raise ValueError(f"Unknown payment type: {payment_type}")
```

**Problems:**
- Adding Stripe requires modifying `PaymentProcessor`
- The class grows indefinitely with each new payment method
- Risk of breaking existing payment types when adding new ones
- Difficult to test individual payment methods in isolation

### The Solution: Use Abstraction for Extension

```python
# GOOD: New payment types can be added without modifying existing code
from abc import ABC, abstractmethod


class PaymentMethod(ABC):
    """Abstract base class for payment methods."""

    @abstractmethod
    def process(self, amount: float) -> str:
        """Process a payment of the given amount."""
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Return the name of this payment method."""
        pass


class CreditCardPayment(PaymentMethod):
    def __init__(self, card_number: str, expiry: str, cvv: str):
        self.card_number = card_number
        self.expiry = expiry
        self.cvv = cvv

    def process(self, amount: float) -> str:
        # Credit card specific logic
        last_four = self.card_number[-4:]
        return f"Charged ${amount} to card ending in {last_four}"

    def get_name(self) -> str:
        return "Credit Card"


class PayPalPayment(PaymentMethod):
    def __init__(self, email: str):
        self.email = email

    def process(self, amount: float) -> str:
        # PayPal specific logic
        return f"Charged ${amount} to PayPal account {self.email}"

    def get_name(self) -> str:
        return "PayPal"


class BitcoinPayment(PaymentMethod):
    def __init__(self, wallet_address: str):
        self.wallet_address = wallet_address

    def process(self, amount: float) -> str:
        # Bitcoin specific logic
        return f"Sent ${amount} worth of BTC to {self.wallet_address[:8]}..."

    def get_name(self) -> str:
        return "Bitcoin"


# Adding a new payment method is just creating a new class!
class StripePayment(PaymentMethod):
    def __init__(self, token: str):
        self.token = token

    def process(self, amount: float) -> str:
        return f"Processed ${amount} via Stripe"

    def get_name(self) -> str:
        return "Stripe"


class PaymentProcessor:
    """Processes payments using any PaymentMethod implementation."""

    def process_payment(self, payment_method: PaymentMethod, amount: float) -> str:
        # This class never needs to change when adding new payment types!
        print(f"Processing {payment_method.get_name()} payment...")
        return payment_method.process(amount)


# Usage
processor = PaymentProcessor()

credit_card = CreditCardPayment("1234567890123456", "12/25", "123")
print(processor.process_payment(credit_card, 99.99))

stripe = StripePayment("tok_visa")
print(processor.process_payment(stripe, 49.99))
```

**Benefits:**
- Adding new payment methods requires zero changes to existing code
- Each payment method is isolated and independently testable
- The `PaymentProcessor` class is simple and stable
- New developers can add payment methods without understanding the entire system

## Liskov Substitution Principle (LSP)

> "Objects of a superclass should be replaceable with objects of its subclasses without breaking the application."

If you have a function that works with a base class, it should work correctly with any derived class. Violations typically occur when subclasses change the expected behavior of inherited methods.

### The Problem: Subclasses That Break Expectations

```python
# BAD: Square violates LSP when substituted for Rectangle
class Rectangle:
    def __init__(self, width: int, height: int):
        self._width = width
        self._height = height

    def set_width(self, width: int) -> None:
        self._width = width

    def set_height(self, height: int) -> None:
        self._height = height

    def get_area(self) -> int:
        return self._width * self._height


class Square(Rectangle):
    def __init__(self, size: int):
        super().__init__(size, size)

    # Override to maintain square invariant - THIS VIOLATES LSP!
    def set_width(self, width: int) -> None:
        self._width = width
        self._height = width  # Also changes height!

    def set_height(self, height: int) -> None:
        self._width = height  # Also changes width!
        self._height = height


def resize_rectangle(rect: Rectangle, width: int, height: int) -> int:
    """This function expects Rectangle behavior."""
    rect.set_width(width)
    rect.set_height(height)
    return rect.get_area()


# This works as expected
rectangle = Rectangle(10, 20)
area = resize_rectangle(rectangle, 5, 10)
print(f"Rectangle area: {area}")  # Output: 50

# This breaks expectations!
square = Square(10)
area = resize_rectangle(square, 5, 10)
print(f"Square area: {area}")  # Output: 100, not 50!
# The function set width to 5, then height to 10
# But Square.set_height also set width to 10!
```

### The Solution: Design for Substitutability

```python
# GOOD: Use composition or separate hierarchies
from abc import ABC, abstractmethod


class Shape(ABC):
    """Abstract base class for shapes."""

    @abstractmethod
    def get_area(self) -> int:
        pass


class Rectangle(Shape):
    def __init__(self, width: int, height: int):
        self._width = width
        self._height = height

    @property
    def width(self) -> int:
        return self._width

    @property
    def height(self) -> int:
        return self._height

    def get_area(self) -> int:
        return self._width * self._height


class Square(Shape):
    def __init__(self, size: int):
        self._size = size

    @property
    def size(self) -> int:
        return self._size

    def get_area(self) -> int:
        return self._size * self._size


# Functions work with the Shape abstraction
def print_area(shape: Shape) -> None:
    print(f"Area: {shape.get_area()}")


rectangle = Rectangle(5, 10)
square = Square(7)

print_area(rectangle)  # Area: 50
print_area(square)     # Area: 49
```

**Key insight:** A square "is a" rectangle mathematically, but in terms of behavior (mutable width and height), they are different. LSP is about behavioral compatibility, not just inheritance hierarchies.

## Interface Segregation Principle (ISP)

> "Clients should not be forced to depend on interfaces they don't use."

Large interfaces should be split into smaller, more specific ones so that clients only need to know about the methods relevant to them.

### The Problem: Fat Interfaces

```python
# BAD: One large interface forces all implementations to define unused methods
from abc import ABC, abstractmethod


class Worker(ABC):
    @abstractmethod
    def work(self) -> str:
        pass

    @abstractmethod
    def eat(self) -> str:
        pass

    @abstractmethod
    def sleep(self) -> str:
        pass

    @abstractmethod
    def recharge(self) -> str:
        pass


class Human(Worker):
    def work(self) -> str:
        return "Human working"

    def eat(self) -> str:
        return "Human eating"

    def sleep(self) -> str:
        return "Human sleeping"

    def recharge(self) -> str:
        # Humans don't recharge! But we're forced to implement this.
        raise NotImplementedError("Humans don't recharge")


class Robot(Worker):
    def work(self) -> str:
        return "Robot working"

    def eat(self) -> str:
        # Robots don't eat! But we're forced to implement this.
        raise NotImplementedError("Robots don't eat")

    def sleep(self) -> str:
        # Robots don't sleep! But we're forced to implement this.
        raise NotImplementedError("Robots don't sleep")

    def recharge(self) -> str:
        return "Robot recharging"
```

### The Solution: Segregated Interfaces

```python
# GOOD: Small, focused interfaces
from abc import ABC, abstractmethod


class Workable(ABC):
    @abstractmethod
    def work(self) -> str:
        pass


class Eatable(ABC):
    @abstractmethod
    def eat(self) -> str:
        pass


class Sleepable(ABC):
    @abstractmethod
    def sleep(self) -> str:
        pass


class Rechargeable(ABC):
    @abstractmethod
    def recharge(self) -> str:
        pass


class Human(Workable, Eatable, Sleepable):
    """Humans work, eat, and sleep - but don't recharge."""

    def work(self) -> str:
        return "Human working"

    def eat(self) -> str:
        return "Human eating"

    def sleep(self) -> str:
        return "Human sleeping"


class Robot(Workable, Rechargeable):
    """Robots work and recharge - but don't eat or sleep."""

    def work(self) -> str:
        return "Robot working"

    def recharge(self) -> str:
        return "Robot recharging"


# Functions can depend on specific interfaces
def perform_work(worker: Workable) -> str:
    return worker.work()


def refuel(entity: Eatable | Rechargeable) -> str:
    if isinstance(entity, Eatable):
        return entity.eat()
    return entity.recharge()
```

**Benefits:**
- Classes only implement what they actually need
- No dummy implementations or `NotImplementedError`
- Functions can specify exactly what interface they require
- Easier to understand what a class can do by looking at its interfaces

## Dependency Inversion Principle (DIP)

> "High-level modules should not depend on low-level modules. Both should depend on abstractions."

This principle is about reducing coupling between components. Instead of high-level business logic depending directly on low-level implementation details, both should depend on abstractions (interfaces).

### The Problem: Direct Dependencies on Concrete Classes

```python
# BAD: High-level OrderService directly depends on low-level MySQLDatabase
class MySQLDatabase:
    def connect(self) -> None:
        print("Connecting to MySQL...")

    def execute_query(self, query: str) -> list:
        print(f"Executing: {query}")
        return [{"id": 1, "product": "Widget", "quantity": 5}]

    def close(self) -> None:
        print("Closing MySQL connection...")


class OrderService:
    def __init__(self):
        # Direct dependency on concrete class!
        self.database = MySQLDatabase()

    def get_orders(self) -> list:
        self.database.connect()
        orders = self.database.execute_query("SELECT * FROM orders")
        self.database.close()
        return orders


# Problems:
# 1. Can't test OrderService without a real MySQL database
# 2. Switching to PostgreSQL requires changing OrderService
# 3. OrderService is tightly coupled to MySQL implementation details
```

### The Solution: Depend on Abstractions

```python
# GOOD: Both high-level and low-level modules depend on abstractions
from abc import ABC, abstractmethod


class Database(ABC):
    """Abstraction that both high and low-level modules depend on."""

    @abstractmethod
    def connect(self) -> None:
        pass

    @abstractmethod
    def execute_query(self, query: str) -> list:
        pass

    @abstractmethod
    def close(self) -> None:
        pass


class MySQLDatabase(Database):
    """Low-level module implementing the Database abstraction."""

    def connect(self) -> None:
        print("Connecting to MySQL...")

    def execute_query(self, query: str) -> list:
        print(f"MySQL executing: {query}")
        return [{"id": 1, "product": "Widget", "quantity": 5}]

    def close(self) -> None:
        print("Closing MySQL connection...")


class PostgreSQLDatabase(Database):
    """Another low-level module - easy to add!"""

    def connect(self) -> None:
        print("Connecting to PostgreSQL...")

    def execute_query(self, query: str) -> list:
        print(f"PostgreSQL executing: {query}")
        return [{"id": 1, "product": "Widget", "quantity": 5}]

    def close(self) -> None:
        print("Closing PostgreSQL connection...")


class InMemoryDatabase(Database):
    """Great for testing!"""

    def __init__(self, data: list = None):
        self.data = data or []

    def connect(self) -> None:
        pass  # No connection needed

    def execute_query(self, query: str) -> list:
        return self.data

    def close(self) -> None:
        pass


class OrderService:
    """High-level module depending on abstraction, not concrete class."""

    def __init__(self, database: Database):
        # Dependency is INJECTED, not created internally
        self.database = database

    def get_orders(self) -> list:
        self.database.connect()
        orders = self.database.execute_query("SELECT * FROM orders")
        self.database.close()
        return orders


# Production usage
mysql_db = MySQLDatabase()
order_service = OrderService(mysql_db)
orders = order_service.get_orders()

# Easy to switch databases
postgres_db = PostgreSQLDatabase()
order_service = OrderService(postgres_db)
orders = order_service.get_orders()

# Easy to test!
test_data = [{"id": 1, "product": "Test Widget", "quantity": 10}]
mock_db = InMemoryDatabase(test_data)
order_service = OrderService(mock_db)
orders = order_service.get_orders()
assert orders == test_data  # Test passes!
```

**Benefits:**
- `OrderService` can work with any database implementation
- Easy to test with mock/in-memory databases
- Switching databases requires no changes to business logic
- New database types can be added without modifying existing code

### Dependency Injection in Practice

Dependency Injection (DI) is the technique used to implement the Dependency Inversion Principle. There are several ways to inject dependencies:

```python
# Constructor Injection (most common, shown above)
class OrderService:
    def __init__(self, database: Database):
        self.database = database


# Method Injection
class OrderService:
    def get_orders(self, database: Database) -> list:
        return database.execute_query("SELECT * FROM orders")


# Property Injection
class OrderService:
    def __init__(self):
        self._database = None

    @property
    def database(self) -> Database:
        return self._database

    @database.setter
    def database(self, db: Database) -> None:
        self._database = db
```

Constructor injection is generally preferred because it makes dependencies explicit and ensures objects are fully initialized.

## How SOLID Principles Work Together

The SOLID principles are interconnected and reinforce each other:

1. **SRP + DIP**: When you separate responsibilities, you naturally create abstractions that can be injected
2. **OCP + DIP**: Depending on abstractions allows extension without modification
3. **ISP + SRP**: Small interfaces often emerge from classes with single responsibilities
4. **LSP + OCP**: Proper substitutability enables safe extension through polymorphism

## Interactive Quiz

Test your understanding of the SOLID principles:

<div id="solid-quiz"></div>

<script>
(function() {
  const questions = [
    {
      question: "A class that handles user authentication, database queries, and email sending violates which principle?",
      options: [
        "Open/Closed Principle",
        "Single Responsibility Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ],
      correct: 1,
      explanation: "The Single Responsibility Principle states that a class should have only one reason to change. This class has at least three responsibilities."
    },
    {
      question: "You need to add a new payment method to your application. Following OCP, you should:",
      options: [
        "Add a new elif branch to the existing payment processor",
        "Create a new class that implements the PaymentMethod interface",
        "Modify the base PaymentMethod class to include the new logic",
        "Create a global function for the new payment type"
      ],
      correct: 1,
      explanation: "The Open/Closed Principle says software should be open for extension but closed for modification. Creating a new class that implements an existing interface extends functionality without modifying existing code."
    },
    {
      question: "What is the main benefit of Dependency Injection?",
      options: [
        "It makes code run faster",
        "It reduces the number of classes needed",
        "It makes code more testable and flexible",
        "It eliminates the need for interfaces"
      ],
      correct: 2,
      explanation: "Dependency Injection allows you to swap implementations easily, including using mock objects for testing. This makes code more testable and flexible."
    },
    {
      question: "A Robot class that inherits from Worker but throws NotImplementedError for eat() and sleep() violates:",
      options: [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Interface Segregation Principle",
        "Dependency Inversion Principle"
      ],
      correct: 2,
      explanation: "The Interface Segregation Principle states that clients should not be forced to depend on interfaces they don't use. The Worker interface is too broad for Robot."
    },
    {
      question: "Which statement best describes the Liskov Substitution Principle?",
      options: [
        "Classes should be substituted with interfaces",
        "Subclasses must be usable in place of their parent class without breaking the program",
        "All classes should extend a common base class",
        "Inheritance should be avoided in favor of composition"
      ],
      correct: 1,
      explanation: "LSP ensures that objects of a superclass can be replaced with objects of a subclass without affecting the correctness of the program."
    }
  ];

  function createQuiz() {
    const container = document.getElementById('solid-quiz');
    if (!container) return;

    let html = '<div class="quiz-container">';

    questions.forEach((q, i) => {
      html += `
        <div class="quiz-question" id="q${i}">
          <h4>Question ${i + 1}</h4>
          <p>${q.question}</p>
          <div class="quiz-options">
            ${q.options.map((opt, j) => `
              <label class="quiz-option">
                <input type="radio" name="q${i}" value="${j}">
                <span>${opt}</span>
              </label>
            `).join('')}
          </div>
          <div class="quiz-feedback" id="feedback${i}" style="display:none;"></div>
        </div>
      `;
    });

    html += `
      <button class="quiz-submit" onclick="checkSolidQuiz()">Check Answers</button>
      <div id="quiz-results" style="display:none;"></div>
    </div>`;

    container.innerHTML = html;
  }

  window.checkSolidQuiz = function() {
    let correct = 0;
    questions.forEach((q, i) => {
      const selected = document.querySelector(`input[name="q${i}"]:checked`);
      const feedback = document.getElementById(`feedback${i}`);

      if (selected) {
        const isCorrect = parseInt(selected.value) === q.correct;
        if (isCorrect) correct++;

        feedback.innerHTML = isCorrect
          ? `<span class="correct">Correct!</span> ${q.explanation}`
          : `<span class="incorrect">Incorrect.</span> ${q.explanation}`;
        feedback.style.display = 'block';
      }
    });

    const results = document.getElementById('quiz-results');
    results.innerHTML = `<h4>Score: ${correct}/${questions.length}</h4>`;
    results.style.display = 'block';
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', createQuiz);
  } else {
    createQuiz();
  }
})();
</script>

<style>
.quiz-container { margin: 20px 0; }
.quiz-question { margin-bottom: 25px; padding: 15px; background: var(--background-secondary, #f5f5f5); border-radius: 8px; }
.quiz-options { margin: 10px 0; }
.quiz-option { display: block; margin: 8px 0; cursor: pointer; }
.quiz-option input { margin-right: 10px; }
.quiz-feedback { margin-top: 10px; padding: 10px; border-radius: 4px; background: var(--background-tertiary, #e0e0e0); }
.quiz-feedback .correct { color: #2e7d32; font-weight: bold; }
.quiz-feedback .incorrect { color: #c62828; font-weight: bold; }
.quiz-submit { padding: 10px 20px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
.quiz-submit:hover { background: #1565c0; }
#quiz-results { margin-top: 20px; padding: 15px; background: var(--background-secondary, #f5f5f5); border-radius: 8px; }
</style>

## Exercises

### Exercise 1: Refactor for Single Responsibility

Take this monolithic `ReportGenerator` class and refactor it following SRP:

```python
class ReportGenerator:
    def generate_report(self, data):
        # Validate data
        if not data:
            raise ValueError("No data provided")

        # Calculate statistics
        total = sum(d['amount'] for d in data)
        average = total / len(data)

        # Format as HTML
        html = f"<h1>Report</h1><p>Total: ${total}</p><p>Average: ${average}</p>"

        # Save to file
        with open('report.html', 'w') as f:
            f.write(html)

        # Send email notification
        import smtplib
        # ... email logic
```

**Goal**: Create separate classes for validation, calculation, formatting, file saving, and notification.

### Exercise 2: Apply Open/Closed Principle

You have a discount calculator that uses if/elif chains. Refactor it to be open for extension:

```python
class DiscountCalculator:
    def calculate(self, customer_type, amount):
        if customer_type == "regular":
            return amount * 0.05
        elif customer_type == "premium":
            return amount * 0.10
        elif customer_type == "vip":
            return amount * 0.15
        # Adding new customer types requires modifying this class
```

**Goal**: Create a `DiscountStrategy` interface so new discount types can be added without modifying existing code.

### Exercise 3: Implement Dependency Injection

Refactor this tightly coupled `NotificationService`:

```python
class NotificationService:
    def __init__(self):
        self.email_client = SMTPClient()  # Direct dependency!
        self.sms_client = TwilioClient()  # Direct dependency!

    def notify(self, user, message):
        self.email_client.send(user.email, message)
        self.sms_client.send(user.phone, message)
```

**Goal**: Use dependency injection so different notification backends can be easily swapped and tested.

## Deliverables

After completing this section, you should be able to answer:

1. What is the Single Responsibility Principle, and why does it make code easier to maintain?
2. How does the Open/Closed Principle enable adding new features without risking existing functionality?
3. What is the difference between Dependency Injection and Dependency Inversion?
4. When might you intentionally violate a SOLID principle, and what are the trade-offs?
5. How do the SOLID principles relate to the layered architecture from the previous section?
