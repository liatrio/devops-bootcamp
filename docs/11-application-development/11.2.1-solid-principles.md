---
docs/11-application-development/11.2.1-solid-principles.md:
  category: Software Development
  estReadingMinutes: 45
  exercises:
    -
      name: Refactor a class to follow SRP
      description: Take a provided monolithic class and refactor it into multiple classes, each with a single responsibility.
      estMinutes: 45
      technologies:
      - Python
    -
      name: Apply Open/Closed Principle to payment processing
      description: Extend a payment system to support new payment methods without modifying existing code.
      estMinutes: 60
      technologies:
      - Python
    -
      name: Implement Dependency Injection
      description: Refactor tightly coupled code to use dependency injection, making it testable and flexible.
      estMinutes: 45
      technologies:
      - Python
---
# SOLID Principles

The SOLID principles are five design principles that help developers create maintainable, flexible, and understandable software. Coined by Robert C. Martin (Uncle Bob), these principles have become fundamental to object-oriented design.

Before diving in, watch [Uncle Bob explain the SOLID principles](https://www.youtube.com/watch?v=TMuno5RZNeE) in his own words to understand the philosophy behind them (sadly he doesn't get through them all).

## Overview

| Principle | Full Name | Key Idea |
| --------- | --------- | -------- |
| **S** | Single Responsibility | One class, one job |
| **O** | Open/Closed | Extend without modifying |
| **L** | Liskov Substitution | Subtypes are substitutable |
| **I** | Interface Segregation | Small, focused interfaces |
| **D** | Dependency Inversion | Depend on abstractions |

## Single Responsibility Principle (SRP)

> "A class should have only one reason to change."

The Single Responsibility Principle states that a class should have only one job or responsibility. When a class handles multiple concerns, changes to one concern can inadvertently affect others.

**Code Smell Warning:** Watch for "God Objects" - classes that grow beyond 200-300 lines or have more than 5-7 methods. If you can't describe a class's purpose in one sentence without using "and", it's probably violating SRP. Class names containing "Manager", "Handler", "Processor", or "Controller" often hide multiple responsibilities.

### The Problem: A Class Doing Too Much

Consider a user management class that handles multiple responsibilities:

```python
# BAD: This class has multiple responsibilities
class UserManager:
    def __init__(self, db_connection):
        self.db = db_connection

    def create_user(self, username, email, password):
        # Validation logic
        if not username or len(username) < 3:
            raise ValueError("Username must be at least 3 characters")
        if "@" not in email:
            raise ValueError("Invalid email format")
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters")

        # Password hashing
        import hashlib
        hashed = hashlib.sha256(password.encode()).hexdigest()

        # Database operations
        self.db.execute(
            "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
            (username, email, hashed)
        )

        # Email notification
        import smtplib
        server = smtplib.SMTP('smtp.example.com', 587)
        server.sendmail(
            'noreply@example.com',
            email,
            f'Welcome {username}! Your account has been created.'
        )
        server.quit()

        # Logging
        with open('user_log.txt', 'a') as f:
            f.write(f"Created user: {username}\n")
```

**Problems with this approach:**
- Changes to email logic require modifying the UserManager class
- You can't test user creation without an SMTP server
- Validation rules are buried inside the creation method
- The class has at least 5 reasons to change (validation, hashing, database, email, logging)

### The Solution: Separate Responsibilities

```python
# GOOD: Each class has a single responsibility

class UserValidator:
    """Handles all user validation logic."""

    def validate_username(self, username: str) -> None:
        if not username or len(username) < 3:
            raise ValueError("Username must be at least 3 characters")

    def validate_email(self, email: str) -> None:
        if "@" not in email:
            raise ValueError("Invalid email format")

    def validate_password(self, password: str) -> None:
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters")

    def validate_user(self, username: str, email: str, password: str) -> None:
        self.validate_username(username)
        self.validate_email(email)
        self.validate_password(password)


class PasswordHasher:
    """Handles password hashing."""

    def hash(self, password: str) -> str:
        import hashlib
        return hashlib.sha256(password.encode()).hexdigest()


class UserRepository:
    """Handles database operations for users."""

    def __init__(self, db_connection):
        self.db = db_connection

    def save(self, username: str, email: str, hashed_password: str) -> dict:
        self.db.execute(
            "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
            (username, email, hashed_password)
        )
        return {"username": username, "email": email}


class EmailService:
    """Handles sending emails."""

    def __init__(self, smtp_host: str, smtp_port: int):
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port

    def send_welcome_email(self, email: str, username: str) -> None:
        import smtplib
        server = smtplib.SMTP(self.smtp_host, self.smtp_port)
        server.sendmail(
            'noreply@example.com',
            email,
            f'Welcome {username}! Your account has been created.'
        )
        server.quit()


class UserLogger:
    """Handles user-related logging."""

    def __init__(self, log_file: str):
        self.log_file = log_file

    def log_creation(self, username: str) -> None:
        with open(self.log_file, 'a') as f:
            f.write(f"Created user: {username}\n")


class UserService:
    """Coordinates user creation using specialized classes."""

    def __init__(
        self,
        validator: UserValidator,
        hasher: PasswordHasher,
        repository: UserRepository,
        email_service: EmailService,
        logger: UserLogger
    ):
        self.validator = validator
        self.hasher = hasher
        self.repository = repository
        self.email_service = email_service
        self.logger = logger

    def create_user(self, username: str, email: str, password: str) -> dict:
        # Each step delegates to a specialized class
        self.validator.validate_user(username, email, password)
        hashed_password = self.hasher.hash(password)
        user = self.repository.save(username, email, hashed_password)
        self.email_service.send_welcome_email(email, username)
        self.logger.log_creation(username)
        return user
```

**Benefits of this approach:**
- Each class can be tested independently
- Changes to email logic only affect `EmailService`
- Validation rules can be reused elsewhere
- Easy to swap implementations (e.g., different logging backends)

**Note on hidden dependencies:** Notice how the bad example had `import hashlib` and `import smtplib` buried inside the method? This is a code smell. It hides dependencies and makes testing harder. Dependencies should be explicit at the class level or injected through the constructor, as shown in the good example.

## Open/Closed Principle (OCP)

> "Software entities should be open for extension but closed for modification."

You should be able to add new functionality without changing existing code. This is typically achieved through abstraction and polymorphism.

**Code Smell Warning:** If you find yourself writing `switch` statements or `if/elif` chains that check the type of an object (e.g., `if type == "credit_card"` or `if isinstance(obj, CreditCard)`), this is usually a sign that you're violating OCP. Each new type requires modifying the switch statement. Instead, use polymorphism to let each type handle its own behavior.

Additionally, passing string identifiers like `"credit_card"` is error-prone (typos cause runtime failures) and violates type safety. Use polymorphic types instead of string-based type systems.

### The Problem: Modifying Existing Code for New Features

```python
# BAD: Adding new payment types requires modifying this class
class PaymentProcessor:
    def process_payment(self, payment_type: str, amount: float) -> str:
        if payment_type == "credit_card":
            # Credit card processing logic
            return f"Processed ${amount} via credit card"
        elif payment_type == "paypal":
            # PayPal processing logic
            return f"Processed ${amount} via PayPal"
        elif payment_type == "bitcoin":
            # Bitcoin processing logic
            return f"Processed ${amount} via Bitcoin"
        # Every new payment type requires adding another elif here!
        else:
            raise ValueError(f"Unknown payment type: {payment_type}")
```

**Problems:**
- Adding Stripe requires modifying `PaymentProcessor`
- The class grows indefinitely with each new payment method
- Risk of breaking existing payment types when adding new ones
- Difficult to test individual payment methods in isolation

### The Solution: Use Abstraction for Extension

```python
# GOOD: New payment types can be added without modifying existing code
from abc import ABC, abstractmethod


class PaymentMethod(ABC):
    """Abstract base class for payment methods."""

    @abstractmethod
    def process(self, amount: float) -> str:
        """Process a payment of the given amount."""
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Return the name of this payment method."""
        pass


class CreditCardPayment(PaymentMethod):
    def __init__(self, card_number: str, expiry: str, cvv: str):
        self.card_number = card_number
        self.expiry = expiry
        self.cvv = cvv

    def process(self, amount: float) -> str:
        # Credit card specific logic
        last_four = self.card_number[-4:]
        return f"Charged ${amount} to card ending in {last_four}"

    def get_name(self) -> str:
        return "Credit Card"


class PayPalPayment(PaymentMethod):
    def __init__(self, email: str):
        self.email = email

    def process(self, amount: float) -> str:
        # PayPal specific logic
        return f"Charged ${amount} to PayPal account {self.email}"

    def get_name(self) -> str:
        return "PayPal"


class BitcoinPayment(PaymentMethod):
    def __init__(self, wallet_address: str):
        self.wallet_address = wallet_address

    def process(self, amount: float) -> str:
        # Bitcoin specific logic
        return f"Sent ${amount} worth of BTC to {self.wallet_address[:8]}..."

    def get_name(self) -> str:
        return "Bitcoin"


# Adding a new payment method is just creating a new class!
class StripePayment(PaymentMethod):
    def __init__(self, token: str):
        self.token = token

    def process(self, amount: float) -> str:
        return f"Processed ${amount} via Stripe"

    def get_name(self) -> str:
        return "Stripe"


class PaymentProcessor:
    """Processes payments using any PaymentMethod implementation."""

    def process_payment(self, payment_method: PaymentMethod, amount: float) -> str:
        # This class never needs to change when adding new payment types!
        print(f"Processing {payment_method.get_name()} payment...")
        return payment_method.process(amount)


# Usage
processor = PaymentProcessor()

credit_card = CreditCardPayment("1234567890123456", "12/25", "123")
print(processor.process_payment(credit_card, 99.99))

stripe = StripePayment("tok_visa")
print(processor.process_payment(stripe, 49.99))
```

**Benefits:**
- Adding new payment methods requires zero changes to existing code
- Each payment method is isolated and independently testable
- The `PaymentProcessor` class is simple and stable
- New developers can add payment methods without understanding the entire system

## Liskov Substitution Principle (LSP)

> "Objects of a superclass should be replaceable with objects of its subclasses without breaking the application."

If you have a function that works with a base class, it should work correctly with any derived class. Violations typically occur when subclasses change the expected behavior of inherited methods.

**Code Smell Warning:** If a subclass throws exceptions that the parent class doesn't throw, or if it requires preconditions the parent doesn't have, it violates LSP. The classic example: a `ReadOnlyList` that inherits from `List` but throws exceptions on `add()`. If you find yourself writing `if isinstance(x, SubClass)` before calling a method, that's a red flag that LSP is being violated.

### The Problem: Subclasses That Break Expectations

```python
# BAD: Square violates LSP when substituted for Rectangle
class Rectangle:
    def __init__(self, width: int, height: int):
        self._width = width
        self._height = height

    def set_width(self, width: int) -> None:
        self._width = width

    def set_height(self, height: int) -> None:
        self._height = height

    def get_area(self) -> int:
        return self._width * self._height


class Square(Rectangle):
    def __init__(self, size: int):
        super().__init__(size, size)

    # Override to maintain square invariant - THIS VIOLATES LSP!
    def set_width(self, width: int) -> None:
        self._width = width
        self._height = width  # Also changes height!

    def set_height(self, height: int) -> None:
        self._width = height  # Also changes width!
        self._height = height


def resize_rectangle(rect: Rectangle, width: int, height: int) -> int:
    """This function expects Rectangle behavior."""
    rect.set_width(width)
    rect.set_height(height)
    return rect.get_area()


# This works as expected
rectangle = Rectangle(10, 20)
area = resize_rectangle(rectangle, 5, 10)
print(f"Rectangle area: {area}")  # Output: 50

# This breaks expectations!
square = Square(10)
area = resize_rectangle(square, 5, 10)
print(f"Square area: {area}")  # Output: 100, not 50!
# The function set width to 5, then height to 10
# But Square.set_height also set width to 10!
```

### The Solution: Design for Substitutability

```python
# GOOD: Use composition or separate hierarchies
from abc import ABC, abstractmethod


class Shape(ABC):
    """Abstract base class for shapes."""

    @abstractmethod
    def get_area(self) -> int:
        pass


class Rectangle(Shape):
    def __init__(self, width: int, height: int):
        self._width = width
        self._height = height

    @property
    def width(self) -> int:
        return self._width

    @property
    def height(self) -> int:
        return self._height

    def get_area(self) -> int:
        return self._width * self._height


class Square(Shape):
    def __init__(self, size: int):
        self._size = size

    @property
    def size(self) -> int:
        return self._size

    def get_area(self) -> int:
        return self._size * self._size


# Functions work with the Shape abstraction
def print_area(shape: Shape) -> None:
    print(f"Area: {shape.get_area()}")


rectangle = Rectangle(5, 10)
square = Square(7)

print_area(rectangle)  # Area: 50
print_area(square)     # Area: 49
```

**Key insight:** A square "is a" rectangle mathematically, but in terms of behavior (mutable width and height), they are different. LSP is about behavioral compatibility, not just inheritance hierarchies.

> _"The representatives of things do not share the relationships of the the things they represent. If anyone here has been divorced, you may have had two lawyers representing you and your spouse, those two lawyers were not themselves getting divorced"_ - Uncle Bob

**Formal LSP rules:**
- Subclasses cannot **strengthen preconditions** (require more than parent)
- Subclasses cannot **weaken postconditions** (promise less than parent)
- Subclasses cannot throw new exceptions not thrown by parent
- Subclasses must maintain **invariants** of the parent class

Example: If `Rectangle.setWidth()` accepts any positive integer, `Square.setWidth()` cannot suddenly require that width equals height - that's a strengthened precondition.

## Interface Segregation Principle (ISP)

> "Clients should not be forced to depend on interfaces they don't use."

Large interfaces should be split into smaller, more specific ones so that clients only need to know about the methods relevant to them.

**Code Smell Warning:** If you find yourself writing `raise NotImplementedError`, returning `None` from interface methods, or adding `pass` with TODO comments, your interface is too fat. This is the most obvious sign of ISP violation. In statically typed languages, watch for classes implementing interfaces where half the methods just throw `UnsupportedOperationException`.

### The Problem: Fat Interfaces

```python
# BAD: One large interface forces all implementations to define unused methods
from abc import ABC, abstractmethod


class Worker(ABC):
    @abstractmethod
    def work(self) -> str:
        pass

    @abstractmethod
    def eat(self) -> str:
        pass

    @abstractmethod
    def sleep(self) -> str:
        pass

    @abstractmethod
    def recharge(self) -> str:
        pass


class Human(Worker):
    def work(self) -> str:
        return "Human working"

    def eat(self) -> str:
        return "Human eating"

    def sleep(self) -> str:
        return "Human sleeping"

    def recharge(self) -> str:
        # Humans don't recharge! But we're forced to implement this.
        raise NotImplementedError("Humans don't recharge")


class Robot(Worker):
    def work(self) -> str:
        return "Robot working"

    def eat(self) -> str:
        # Robots don't eat! But we're forced to implement this.
        raise NotImplementedError("Robots don't eat")

    def sleep(self) -> str:
        # Robots don't sleep! But we're forced to implement this.
        raise NotImplementedError("Robots don't sleep")

    def recharge(self) -> str:
        return "Robot recharging"
```

### The Solution: Segregated Interfaces

```python
# GOOD: Small, focused interfaces
from abc import ABC, abstractmethod


class Workable(ABC):
    @abstractmethod
    def work(self) -> str:
        pass


class Eatable(ABC):
    @abstractmethod
    def eat(self) -> str:
        pass


class Sleepable(ABC):
    @abstractmethod
    def sleep(self) -> str:
        pass


class Rechargeable(ABC):
    @abstractmethod
    def recharge(self) -> str:
        pass


class Refuelable(ABC):
    """Common interface for entities that need refueling."""

    @abstractmethod
    def refuel(self) -> str:
        pass


class Human(Workable, Eatable, Sleepable, Refuelable):
    """Humans work, eat, and sleep - but don't recharge."""

    def work(self) -> str:
        return "Human working"

    def eat(self) -> str:
        return "Human eating"

    def sleep(self) -> str:
        return "Human sleeping"

    def refuel(self) -> str:
        """Humans refuel by eating."""
        return self.eat()


class Robot(Workable, Rechargeable, Refuelable):
    """Robots work and recharge - but don't eat or sleep."""

    def work(self) -> str:
        return "Robot working"

    def recharge(self) -> str:
        return "Robot recharging"

    def refuel(self) -> str:
        """Robots refuel by recharging."""
        return self.recharge()


# Functions can depend on specific interfaces
def perform_work(worker: Workable) -> str:
    return worker.work()


def refuel_entity(entity: Refuelable) -> str:
    """
    Uses polymorphism instead of type checking.
    No modification needed when adding new entity types!
    """
    return entity.refuel()
```

**Benefits:**
- Classes only implement what they actually need
- No dummy implementations or `NotImplementedError`
- Functions can specify exactly what interface they require
- Easier to understand what a class can do by looking at its interfaces

**Note on the refuel_entity function:** This demonstrates good use of polymorphism. Instead of checking types with `if isinstance(entity, Eatable)`, we define a common `Refuelable` interface that both `Human` and `Robot` implement. Each class decides how it refuels. This follows OCP - if you add a `Cyborg` class later, `refuel_entity()` doesn't need to change at all. Remember Uncle Bob's wisdom: type-checking with switch statements or isinstance() is often a code smell indicating you should be using polymorphism instead.

## Dependency Inversion Principle (DIP)

> "High-level modules should not depend on low-level modules. Both should depend on abstractions."

This principle is about reducing coupling between components. Instead of high-level business logic depending directly on low-level implementation details, both should depend on abstractions (interfaces).

**Code Smell Warning:** If you see constructor calls like `MySQLDatabase()` or `SMTPClient()` inside your business logic, you're probably violating DIP. The phrase "don't call us, we'll call you" (Hollywood Principle) applies here. Dependencies should be provided to you (injected), not created by you. Exceptions: creating simple value objects (dates, strings) or using the builder pattern.

### The Problem: Direct Dependencies on Concrete Classes

```python
# BAD: High-level OrderService directly depends on low-level MySQLDatabase
class MySQLDatabase:
    def connect(self) -> None:
        print("Connecting to MySQL...")

    def execute_query(self, query: str) -> list:
        print(f"Executing: {query}")
        return [{"id": 1, "product": "Widget", "quantity": 5}]

    def close(self) -> None:
        print("Closing MySQL connection...")


class OrderService:
    def __init__(self):
        # Direct dependency on concrete class!
        self.database = MySQLDatabase()

    def get_orders(self) -> list:
        self.database.connect()
        orders = self.database.execute_query("SELECT * FROM orders")
        self.database.close()
        return orders


# Problems:
# 1. Can't test OrderService without a real MySQL database
# 2. Switching to PostgreSQL requires changing OrderService
# 3. OrderService is tightly coupled to MySQL implementation details
```

### The Solution: Depend on Abstractions

```python
# GOOD: Both high-level and low-level modules depend on abstractions
from abc import ABC, abstractmethod


class Database(ABC):
    """Abstraction that both high and low-level modules depend on."""

    @abstractmethod
    def connect(self) -> None:
        pass

    @abstractmethod
    def execute_query(self, query: str) -> list:
        pass

    @abstractmethod
    def close(self) -> None:
        pass


class MySQLDatabase(Database):
    """Low-level module implementing the Database abstraction."""

    def connect(self) -> None:
        print("Connecting to MySQL...")

    def execute_query(self, query: str) -> list:
        print(f"MySQL executing: {query}")
        return [{"id": 1, "product": "Widget", "quantity": 5}]

    def close(self) -> None:
        print("Closing MySQL connection...")


class PostgreSQLDatabase(Database):
    """Another low-level module - easy to add!"""

    def connect(self) -> None:
        print("Connecting to PostgreSQL...")

    def execute_query(self, query: str) -> list:
        print(f"PostgreSQL executing: {query}")
        return [{"id": 1, "product": "Widget", "quantity": 5}]

    def close(self) -> None:
        print("Closing PostgreSQL connection...")


class InMemoryDatabase(Database):
    """Great for testing!"""

    def __init__(self, data: list = None):
        self.data = data or []

    def connect(self) -> None:
        pass  # No connection needed

    def execute_query(self, query: str) -> list:
        return self.data

    def close(self) -> None:
        pass


class OrderService:
    """High-level module depending on abstraction, not concrete class."""

    def __init__(self, database: Database):
        # Dependency is INJECTED, not created internally
        self.database = database

    def get_orders(self) -> list:
        self.database.connect()
        orders = self.database.execute_query("SELECT * FROM orders")
        self.database.close()
        return orders


# Production usage
mysql_db = MySQLDatabase()
order_service = OrderService(mysql_db)
orders = order_service.get_orders()

# Easy to switch databases
postgres_db = PostgreSQLDatabase()
order_service = OrderService(postgres_db)
orders = order_service.get_orders()

# Easy to test!
test_data = [{"id": 1, "product": "Test Widget", "quantity": 10}]
mock_db = InMemoryDatabase(test_data)
order_service = OrderService(mock_db)
orders = order_service.get_orders()
assert orders == test_data  # Test passes!
```

**Benefits:**
- `OrderService` can work with any database implementation
- Easy to test with mock/in-memory databases
- Switching databases requires no changes to business logic
- New database types can be added without modifying existing code

### Dependency Injection in Practice

Dependency Injection (DI) is the technique used to implement the Dependency Inversion Principle. There are several ways to inject dependencies:

```python
# Constructor Injection (most common, shown above)
class OrderService:
    def __init__(self, database: Database):
        self.database = database


# Method Injection
class OrderService:
    def get_orders(self, database: Database) -> list:
        return database.execute_query("SELECT * FROM orders")


# Property Injection
class OrderService:
    def __init__(self):
        self._database = None

    @property
    def database(self) -> Database:
        return self._database

    @database.setter
    def database(self, db: Database) -> None:
        self._database = db
```

Constructor injection is generally preferred because it makes dependencies explicit and ensures objects are fully initialized.

**Code Smell Warning:** Look at your constructor signatures. If you see concrete class names (like `MySQLDatabase`, `SMTPMailer`) instead of interfaces (like `Database`, `MailSender`), you're violating DIP. Your constructor signature is a contract - it should depend on abstractions, not implementations.

## How SOLID Principles Work Together

The SOLID principles are interconnected and reinforce each other:

1. **SRP + DIP**: When you separate responsibilities, you naturally create abstractions that can be injected
2. **OCP + DIP**: Depending on abstractions allows extension without modification
3. **ISP + SRP**: Small interfaces often emerge from classes with single responsibilities
4. **LSP + OCP**: Proper substitutability enables safe extension through polymorphism

## Interactive Quiz

Test your understanding of the SOLID principles:

<div class="quizdown">
  <div id="chapter-11/11.2.1/solid-principles-quiz.js"></div>
</div>

## Exercises

### Exercise 1: Refactor for Single Responsibility

Take this monolithic `ReportGenerator` class and refactor it following SRP:

```python
class ReportGenerator:
    def generate_report(self, data):
        # Validate data
        if not data:
            raise ValueError("No data provided")

        # Calculate statistics
        total = sum(d['amount'] for d in data)
        average = total / len(data)

        # Format as HTML
        html = f"<h1>Report</h1><p>Total: ${total}</p><p>Average: ${average}</p>"

        # Save to file
        with open('report.html', 'w') as f:
            f.write(html)

        # Send email notification
        import smtplib
        # ... email logic
```

**Goal**: Create separate classes for validation, calculation, formatting, file saving, and notification.

### Exercise 2: Apply Open/Closed Principle

You have a discount calculator that uses if/elif chains. Refactor it to be open for extension:

```python
class DiscountCalculator:
    def calculate(self, customer_type, amount):
        if customer_type == "regular":
            return amount * 0.05
        elif customer_type == "premium":
            return amount * 0.10
        elif customer_type == "vip":
            return amount * 0.15
        # Adding new customer types requires modifying this class
```

**Goal**: Create a `DiscountStrategy` interface so new discount types can be added without modifying existing code.

### Exercise 3: Implement Dependency Injection

Refactor this tightly coupled `NotificationService`:

```python
class NotificationService:
    def __init__(self):
        self.email_client = SMTPClient()  # Direct dependency!
        self.sms_client = TwilioClient()  # Direct dependency!

    def notify(self, user, message):
        self.email_client.send(user.email, message)
        self.sms_client.send(user.phone, message)
```

**Goal**: Use dependency injection so different notification backends can be easily swapped and tested.

## Deliverables

After completing this section, you should be able to answer:

1. What is the Single Responsibility Principle, and why does it make code easier to maintain?
2. How does the Open/Closed Principle enable adding new features without risking existing functionality?
3. What is the difference between Dependency Injection and Dependency Inversion?
4. When might you intentionally violate a SOLID principle, and what are the trade-offs?
5. How do the SOLID principles relate to the layered architecture from the previous section?
