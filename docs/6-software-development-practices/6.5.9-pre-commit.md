---
docs/6-software-development-practices/6.5.9-pre-commit.md:
  category: Software Quality
  estReadingMinutes: 12
  exercises:
    -
      name: Create a basic Git pre-commit hook
      description: Implement a simple shell pre-commit hook that runs a fast check.
      estMinutes: 20
      technologies:
      - Git
      - Bash
    -
      name: Configure pre-commit to run local tasks
      description: Add a .pre-commit-config.yaml that delegates to Taskfile targets for formatting and linting.
      estMinutes: 60
      technologies:
      - pre-commit
      - Taskfile.dev
    -
      name: Align local hooks with CI
      description: Reuse the same Taskfile targets from pre-commit in a GitHub Actions workflow.
      estMinutes: 30
      technologies:
      - GitHub Actions
      - Taskfile.dev
      - pre-commit
---
# Git Hooks and pre-commit

Git hooks let you run scripts at key points in the Git workflow (pre-commit, post-commit, pre-push, etc). You can find samples in the `.git/hooks/` directory of a repository. A common pattern is to run quick checks before a commit to catch issues early. The open source tool pre-commit makes these checks portable and consistent across your team.

## Goals

This section will give you experience with:

- Understanding Git hooks and the value of pre-commit checks
- Comparing ad-hoc hooks vs. using the pre-commit framework
- Delegating to a single source of truth (Taskfile) so local hooks and CI run the same commands

## Setup

1. Clone the bootcamp repository if you haven't already and navigate to the `example/ch6/pre-commit-flask` folder for the test application that will be used throughout these exercise.
2. You will want to create a GitHub repo for these exercise, and you'll want to upload the test application to your repo.

## Exercise 1 - Vanilla Git pre-commit hook

### Overview

- In this exercise we will be using a vanilla git pre-commit hook to prevent commits with obvious issues

### Steps

Create a minimal hook that prevents commits with obvious issues and note portability limitations (hooks live in `.git/hooks/` and are not versioned by default).

1. Create `.git/hooks/pre-commit` and make it executable.
2. Add a small, fast check:

```bash
#!/usr/bin/env bash
set -euo pipefail

# Example: block commits with WIP in the message
MSG_FILE="$(git rev-parse --git-path COMMIT_EDITMSG)"
if grep -qi '\bWIP\b' "$MSG_FILE"; then
  echo "Commit blocked: remove 'WIP' from the message." >&2
  exit 1
fi

echo "pre-commit: OK"
```

?> Note: This approach isnâ€™t portable across machines unless you distribute and install it. Frameworks like pre-commit solve this.

## Exercise 2 - Use pre-commit for Local Checks

### Overview

- In this exercise we will be using pre-commit to run fast, local checks to catch issues before committing.
- We will be creating a `.pre-commit-config.yaml` file that can be versioned and shared with our team.

![pre-commit logo](img6/pre-commit.png ":size=120px :class=img-shadow-center :alt= pre-commit logo")

### Steps

1. Install pre-commit. See instructions [here](https://pre-commit.com/#install).
2. Create a `.pre-commit-config.yaml` with hooks such as Black, isort, Ruff, and optional mypy. Prefer fast auto-fixes on commit and move slower checks to pre-push/CI
3. Install pre-commit and enable hooks.

- Optionally run `pre-commit run --all-files` to bootstrap on an existing repo.

!> pre-commit can execute code from remote repos. Pin versions with `rev`, prefer trusted sources, or use `repo: local` to run only your own scripts/Taskfile.

Reference docs:

- [pre-commit](https://pre-commit.com)
- [pre-commit-hooks (GitHub Repository)](https://github.com/pre-commit/pre-commit-hooks)
- [Black](https://black.readthedocs.io)
- [isort](https://pycqa.github.io/isort/)
- [Ruff](https://docs.astral.sh/ruff/)
- [mypy](https://mypy.readthedocs.io/)
- [pytest](https://docs.pytest.org/)

?> Minimal local setup to run the app and tests (run in your repo):

```zsh
python -m venv .venv && source .venv/bin/activate
pip install flask pytest pre-commit
```

## Exercise 3 - Introduce Taskfile and Mirror in CI

Introduce a `Taskfile.yml` as your single source of truth for format/lint/test, then mirror those commands in CI.

### Steps

1. Install Task. See intructions [here](https://taskfile.dev/docs/installation).
2. Create a `Taskfile.yml` with `format`, `lint`, `check`, and `test` tasks that operate on `src` and `tests`.
3. Create a GitHub Actions workflow to run to match local testing behavior.
4. Optionally update your pre-commit hooks to call `task` for consistency, or keep pre-commit running individual tools if you prefer.

### Deliverables

- Discuss trade-offs between vanilla Git hooks, pre-commit, and a shared `core.hooksPath` directory.
- Which checks belong in pre-commit vs. pre-push vs. CI, and why? How do you keep hooks fast without losing coverage?
- How would you ensure local checks and CI stay in sync over time? What are common failure modes and mitigations?
- What security considerations exist when consuming remote pre-commit hooks, and how would you mitigate them?
