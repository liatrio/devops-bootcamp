---
docs/6-software-development-practices/6.5.9-pre-commit.md:
  category: Software Quality
  estReadingMinutes: 12
  exercises:
    -
      name: Create a basic Git pre-commit hook
      description: Implement a simple shell pre-commit hook that runs a fast check.
      estMinutes: 20
      technologies:
      - Git
      - Bash
    -
      name: Configure pre-commit to run local tasks
      description: Add a .pre-commit-config.yaml that delegates to Taskfile targets for formatting and linting.
      estMinutes: 60
      technologies:
      - pre-commit
      - Taskfile.dev
    -
      name: Align local hooks with CI
      description: Reuse the same Taskfile targets from pre-commit in a GitHub Actions workflow.
      estMinutes: 30
      technologies:
      - GitHub Actions
      - Taskfile.dev
      - pre-commit
---
# Git Hooks

**Git hooks** are scripts that run automatically at key points in the Git workflow—such as before committing (`pre-commit`), after committing (`post-commit`), or before pushing (`pre-push`). Every Git repository includes sample hooks in the `.git/hooks/` directory.

Hooks are a powerful way to **shift feedback left** by catching issues early, before they reach your team or CI pipeline. With hooks, you can automate quality checks like running linters, formatters, unit tests, secret scans, and commit message validation.

However, hooks aren't a replacement for CI, they're a complementary layer. Choose your checks carefully: slow or heavy hooks frustrate developers and tempt them to skip verification with `git commit --no-verify`. Balance catching issues early with keeping commits fast.

Git hooks are not without their challenges. By default, hooks live in the local `.git/hooks/` directory and are not versioned with the repository. This makes sharing hooks across a team cumbersome, as each developer must manually copy hook scripts to their local environment. In this section we will also take a look at some tools that help manage Git hooks in a more scalable and maintainable way.

## Goals

This section will give you experience with:

- Understanding Git hooks and the value of pre-commit checks
- Comparing ad-hoc hooks vs. using the pre-commit framework
- Delegating to a single source of truth (Taskfile) so local hooks and CI run the same commands

## Setup

1. Clone the bootcamp repository if you haven't already and navigate to the `example/ch6/pre-commit-flask` folder for the test application that will be used throughout these exercise.
2. You will want to create a GitHub repo for these exercise, and you'll want to upload the test application to your repo.

## Exercise 1 - Vanilla Git pre-commit hook

### Overview

In this exercise, you'll create a simple Git hook without external frameworks. This helps you understand how hooks work and their limitations before introducing a management tool.

### Steps

You'll create a minimal hook that blocks commits with obvious issues.

1. Create a Git hook (`.git/hooks/`) that will block commits that contain the word "WIP" in the commit message.
2. Now try to commit a change with "WIP" in the message and observe what happens.
3. Talk amongst your group: Which hook did you use to implement this functionality? Explain its purpose. See if there are other hooks you could leverage for this use case.

?> **Why portability matters:** Hooks stored in `.git/hooks/` only work on your local machine. Your teammates won't have them unless you manually distribute the files. This is why pre-commit—which uses version-controlled configuration—is the industry standard.

## Exercise 2 - Use pre-commit for Local Checks

### Overview

Now you'll graduate from vanilla hooks to **pre-commit**, a framework that makes checks portable, versionable, and team-friendly. You'll create a `.pre-commit-config.yaml` file that lives in your repository, ensuring every team member runs identical checks with one command.

![pre-commit logo](img6/pre-commit.png ":size=120px :class=img-shadow-center :alt= pre-commit logo")

### Steps

1. **Install pre-commit** by following the [official instructions](https://pre-commit.com/#install).
2. **Create a `.pre-commit-config.yaml`** file in your repository root with fast, auto-fixing hooks:
   - **Black** – code formatting
   - **isort** – import organization
   - **Ruff** – linting
   - **mypy** (optional) – type checking

   *Pro tip:* Keep hooks fast on `pre-commit` (auto-fixers like Black). Move slower checks (like mypy or tests) to `pre-push` or CI to avoid slowing down commits.

3. **Install and enable pre-commit** hooks in your local repository:
   ```bash
   pre-commit install
   ```

4. (Optional) **Bootstrap on existing code** by running all hooks against existing files:
   ```bash
   pre-commit run --all-files
   ```

!> **Security note:** Always pin versions using the `rev` field, stick to well-known and trusted sources, or use `repo: local` to run only your own scripts or Taskfile targets.

## Exercise 3 - Introduce Taskfile and Mirror in CI

### Overview

Because local hooks are not a replacement for CI (`--no-verify` exists!), we need to ensure that our local checks exist in CI. Now we find ourselves maintaining two sets of configurations: one for local pre-commit hooks and another for CI workflows. One strategy for this is to add a task runner like **Taskfile.dev** to define reusable tasks for formatting, linting, type checking, and testing. Then we can leverage those same tasks in both pre-commit and CI, ensuring consistency.

### Steps

1. **Install Task** by following the [official installation guide](https://taskfile.dev/docs/installation).
2. **Create a `Taskfile.yml`** in your repository root with reusable tasks:
   - `format` – Auto-fix code style (Black, isort)
   - `lint` – Check for issues (Ruff)
   - `check` – Run type checks (mypy)
   - `test` – Run unit tests (pytest)

   Each task should operate on your `src` and `tests` directories.

3. Update your `.pre-commit-config.yaml` to call your task targets instead of running individual tools directly
4. **Create a GitHub Actions workflow** (e.g., `.github/workflows/ci.yml`) that runs the same commands in CI that your pre-commit hooks run locally.

### Deliverables

Reflect on these questions and document your answers:

- Compare vanilla hooks and  pre-commit framework. When would you use each?
- Which lifecycle stage did you put what checks in and why?
- What risks exist when using the pre-commit framework, and how would you design your setup to mitigate those risks?
- What are the pros and cons of leveraging the community hooks vs. delegating to your own Taskfile targets?
