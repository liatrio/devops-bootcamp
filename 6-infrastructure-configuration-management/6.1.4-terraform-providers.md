# Terraform Providers

At this point you should have a good grasp of how to declaratively define infrastructure as code and manage the state of that infrastructure using Terraform. Now we are going to pull back the curtain and take a deep dive into how Terraform works behind the scenes.

All resources and data sources in Terraform are created by a **provider**. Providers are Terraform plugins that define how resources are declared and how the state of those resources should be reconciled. Anyone can write a Terraform provider and providers can be shared publicly or privately via provider repositories. This extensibility is part of what makes Terraform so powerful.

?> Take a look at the providers that are published to the [official Terraform repository](https://registry.terraform.io/browse/providers)

In this section you will write your own Terraform provider to interact with an API we have written. The API defines some trivial endpoints which simulate operations to create, read, update and delete some resources. The API doesn't provide any real functionality but for the purposes of these exercises you should imagine that it provides an interface to configure a real service.

When you finish with this section you should have a much better understanding of how Terraform providers work which will help you learn and use other providers.

Throughout this section it will be helpful to refer to the [Custom Framework Providers](https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework) tutorial for example code, however there are significant differences between those tutorials and these exercises.

!> Be careful when googling for examples. There are many tutorials written for different versions of the Go Terraform plugin library that will not work with these exercises.

### Setup

Before starting on the exercise it is recommended

### Exercise 1: Provider Boilerplate

This exercise will walk you through setting up the boilerplate for a Terraform provider and ensure you can test it locally.

1. Clone the [terraform-provider-scaffolding](https://github.com/hashicorp/terraform-provider-scaffolding-framework) repo.

2. Change the provider name to `devops-bootcamp` and configure the provider server address as `liatr.io/terraform/devops-bootcamp`

3. Test that the provider executes correctly by running `go run main.go`. You should see the following output:

   ?> This binary is a plugin. These are not meant to be executed directly. Please execute the program that consumes these plugins, which will load any plugins automatically exit status 1

4. Build a binary for your provider `go build -o terraform-provider-devops-bootcamp`

5. Edit `~/.terraformrc` and add the follow dev override to use the local version of your provider:
    ```go
    provider_installation {

      dev_overrides {
          "liatr.io/terraform/devops-bootcamp" = "PATH_TO_PROVIDER"
      }

      direct {}
    }
    ```

6. Create a Terraform module with the following configuration to test your provider:
    ```go
    terraform {
      required_providers {
        devops-bootcamp = {
          source = "liatr.io/terraform/devops-bootcamp"
        }
      }
    }

    provider "devops-bootcamp" {
      # example configuration here
    }
    ```

7. Run `terraform plan` to ensure Terraform can find and use your provider.

### API Overview

This section of the boot camp will focus on using an ephemeral API
([API ReadMe](https://github.com/liatrio/devops-bootcamp/blob/a331c9598fdd5187eb324a9b54578e45b7a5dfb9/examples/ch6/devops-api/readMe.md))
  that the ferrets wave made. Take a moment to familiarize yourselves with the API.  It is important to know the overall structure of the API, and the components that you will need to create the custom terraform provider.
The API is using a web framework called [GIN](https://github.com/gin-gonic/gin) here is the link if you wanted to go more in-depth

The overall API is composed of 4 resources as shown below

Resources / Properties

1. Engineer - an individual engineer

    - id (unique numeric or alphanumeric identifier)
    - name (string)
    - email (string: valid email address format)

2. Developer - a collection of developer engineers

    - id (unique numeric or alphanumeric identifier)
    - name (string)
    - engineers (list of engineer resources)

3. Operations - a collection of operations engineers

    - id (unique numeric or alphanumeric identifier)
    - name (string)
    - engineers (list of engineer resources)

4. DevOps - a combination of a collection of developer and operations engineers

    - id (unique numeric or alphanumeric identifier)
    - dev (dev resources)
    - ops (ops resource)

### Custom Provider Overview

Terraform providers work closely with the idea of CRUD operations. Meaning that the providers
try to classify API functionality into 4 groups, here are examples related to our API:

- C[reate]
  - Creates new resource: dev, ops, devops, engineers
- R[ead]
  - Read in an existing resource
- U[pdate]
  - Update an existing resource, however we can not affect the sub-resources (engineers) inside it
- D[elete]
  - Deletes an existing resource, however we can not affect those resource's children

### Schema

The terraform provider framework manages data through its schema. The schema is the structure of data
internal to the provider. This schema should loosely mirror the API data structure.[schema docs](https://developer.hashicorp.com/terraform/plugin/sdkv2/schemas)

#### File Hierarchy

<center>

![boiler plate file tree](img6/file_tree.png ':size=400x600')

</center>

### Exercise 2: Implementing the provider

> We are going to be refrencing the Hashicorp documentation throughout the next excersise

Let's talk about how to get started with creating a custom provider. It's important to know that there are providers available for AWS, Azure, GCP â€¦
Let's begin by setting up the provider.go, add the starter code below your goal is to figure out what belongs where.

Steps:

1. In internal/provider/provider.go we are going to paste the provider.go example from the documentation. Read through the documentation to find out what a provider is, and how it will be used.

This is the starter code from the documentation

```go
package hashicups

import (
    "context"

    "github.com/hashicorp/terraform-plugin-framework/datasource"
    "github.com/hashicorp/terraform-plugin-framework/diag"
    "github.com/hashicorp/terraform-plugin-framework/provider"
    "github.com/hashicorp/terraform-plugin-framework/resource"
    "github.com/hashicorp/terraform-plugin-framework/tfsdk"
)

// Ensure the implementation satisfies the expected interfaces
var (
    _ provider.Provider = &hashicupsProvider{}
)

// New is a helper function to simplify provider server and testing implementation.
func New() provider.Provider {
    return &hashicupsProvider{}
}

// hashicupsProvider is the provider implementation.
type hashicupsProvider struct{}

// Metadata returns the provider type name.
func (p *hashicupsProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) {
    resp.TypeName = "hashicups"
}

// GetSchema defines the provider-level schema for configuration data.
func (p *hashicupsProvider) GetSchema(_ context.Context) (tfsdk.Schema, diag.Diagnostics) {
    return tfsdk.Schema{}, nil
}

// Configure prepares a HashiCups API client for data sources and resources.
func (p *hashicupsProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) {
}

// DataSources defines the data sources implemented in the provider.
func (p *hashicupsProvider) DataSources(_ context.Context) []func() datasource.DataSource {
    return nil
}

// Resources defines the resources implemented in the provider.
func (p *hashicupsProvider) Resources(_ context.Context) []func() resource.Resource {
    return nil
}
```

### Exercise 3: Schema

- What is a Schema ?
- What goes in a Schema ?

# **add additional stuff here**

### Exercise 4: Implementing Engineer resource and datasource

1. Create a file engineer_data_source.go
2. Define the initial data source type.
3. Add data source to provider.
4. Implement the Engineeer client in the data source.
5. Define the data source schema.
6. Define the data source data model.
7. Define the data source read logic.
8. Check if read works.

?> We are going to have to implement the other CRUD operations, please look at the Hashicorp documentation as a reference.

### Exercise 5: implementing the Wrapper

!> You can choose to take a different route as long as it does not take an absurd amount of time

For this exercise we decided to use a [hashicorp client wrapper](https://github.com/hashicorp-demoapp/hashicups-client-go) as a reference.

?> For the wrapper you do not have to implement a models.go - reference [devops-resource](https://github.com/liatrio/devops-bootcamp/blob/64840527f1504e1378402849e3ddbaef0be2a0fb/examples/ch6/devops-resources/README.md) documentation to reference this module to be used in place of models.go

# **add additional stuff here**

### Exercise 6: Implementing Dev, Ops, DevOps resource & datasource

Implementing the next resoruces are going to be similar to the implementation of the engineer resoruce. We are going to be following the Hashicorp Documentaion to co

1. begin with implementing the read functionality

## Deliverables

- What is a Schema?
- What goes in a Schema?
